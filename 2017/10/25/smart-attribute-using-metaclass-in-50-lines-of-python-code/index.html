<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="IdeaWand" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="0x00 背景由于工作需要，最近学习Python元编程方面的东西。本文介绍了Metaclass的一个示例，是笔者在学习过程中编写的一个小例子，虽然只有50行代码，但其中涉及了闭包、元编程等内容，而且具有较高的实用性。 Let’s Go!  注：本文以Python3.6为例，早期版本中元类的使用方式与本文所述方式不同。   上述目的也可以通过装饰器或者闭包实现，不过这里是为了学习元类，因此使用元类来">
<meta name="keywords" content="Python">
<meta property="og:type" content="article">
<meta property="og:title" content="Python之Metaclass元类详解与实战:50行代码实现【智能属性】">
<meta property="og:url" content="http://blog.ideawand.com/2017/10/25/smart-attribute-using-metaclass-in-50-lines-of-python-code/index.html">
<meta property="og:site_name" content="IdeaWand">
<meta property="og:description" content="0x00 背景由于工作需要，最近学习Python元编程方面的东西。本文介绍了Metaclass的一个示例，是笔者在学习过程中编写的一个小例子，虽然只有50行代码，但其中涉及了闭包、元编程等内容，而且具有较高的实用性。 Let’s Go!  注：本文以Python3.6为例，早期版本中元类的使用方式与本文所述方式不同。   上述目的也可以通过装饰器或者闭包实现，不过这里是为了学习元类，因此使用元类来">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-11-22T14:55:34.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python之Metaclass元类详解与实战:50行代码实现【智能属性】">
<meta name="twitter:description" content="0x00 背景由于工作需要，最近学习Python元编程方面的东西。本文介绍了Metaclass的一个示例，是笔者在学习过程中编写的一个小例子，虽然只有50行代码，但其中涉及了闭包、元编程等内容，而且具有较高的实用性。 Let’s Go!  注：本文以Python3.6为例，早期版本中元类的使用方式与本文所述方式不同。   上述目的也可以通过装饰器或者闭包实现，不过这里是为了学习元类，因此使用元类来">

<link rel="canonical" href="http://blog.ideawand.com/2017/10/25/smart-attribute-using-metaclass-in-50-lines-of-python-code/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

<script data-ad-client="ca-pub-6889177530753831" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <title>Python之Metaclass元类详解与实战:50行代码实现【智能属性】 | IdeaWand</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-109133538-1"></script>
    <script>
      var host = window.location.hostname;
      if (host !== "localhost" || !true) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-109133538-1');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?bbacc323b97a99015e18a0f4ac809c48";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">IdeaWand</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">A Wand Makes Your Ideas Come True</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.ideawand.com/2017/10/25/smart-attribute-using-metaclass-in-50-lines-of-python-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Myrfy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IdeaWand">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Python之Metaclass元类详解与实战:50行代码实现【智能属性】
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-25 20:51:21" itemprop="dateCreated datePublished" datetime="2017-10-25T20:51:21+08:00">2017-10-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2017-11-22 22:55:34" itemprop="dateModified" datetime="2017-11-22T22:55:34+08:00">2017-11-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h1><p>由于工作需要，最近学习Python元编程方面的东西。本文介绍了Metaclass的一个示例，是笔者在学习过程中编写的一个小例子，虽然只有50行代码，但其中涉及了闭包、元编程等内容，而且具有较高的实用性。 Let’s Go!</p>
<blockquote>
<p>注：本文以Python3.6为例，早期版本中元类的使用方式与本文所述方式不同。<br>   上述目的也可以通过装饰器或者闭包实现，不过这里是为了学习元类，因此使用元类来做。</p>
</blockquote>
<h1 id="0x01-我们的目标（没有蛀-牙Bug）"><a href="#0x01-我们的目标（没有蛀-牙Bug）" class="headerlink" title="0x01 我们的目标（没有蛀 牙Bug）"></a>0x01 我们的目标（没有<del>蛀 牙</del>Bug）</h1><p>为了了解元类是什么，我们先看一个很实用的例子，这样先知道了目标，再去分析后面的原理，大家思路会清晰一些。<br>我们要实现的目标类似于ORM框架：用一个Python类来表示一个Model，这个Model具有很多属性用来存储数据，我们可以为这些属性设置约束条件（例如数据类型等），当给这些属性进行赋值操作时，会自动根据约束检验数据是否合法，就像下面这样：</p>
<p>假设我们要定义一个叫做News的Model用来代表一片新闻，那么我希望能够这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义News类作为保存新闻信息的Model</span></span><br><span class="line"><span class="comment"># SmartAttrBase为News类的基类</span></span><br><span class="line"><span class="comment"># SmartAttrDesc类用来存储各个字段的约束条件</span></span><br><span class="line"><span class="comment"># SmartAttrBase和SmartAttrDesc类的具体实现在后文中会有介绍，目前不必关心。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">News</span><span class="params">(SmartAttrBase)</span>:</span></span><br><span class="line">    title = SmartAttrDesc(default=<span class="string">""</span>, type_=str, func=<span class="keyword">lambda</span> x: x.upper())</span><br><span class="line">    content = SmartAttrDesc(default=<span class="string">""</span>, type_=str)</span><br><span class="line">    publisher = SmartAttrDesc(default=<span class="string">""</span>, type_=str)</span><br><span class="line">    publish_time = SmartAttrDesc(default=<span class="number">0</span>, type_=int)</span><br></pre></td></tr></table></figure>

<p>上面的News Model具有4个属性，其中3个是字符串类型，1个是整数类型，对于title字段，我们要求无论传入什么内容，都转换为大写形式进行存储。如果提供的数据类型不符，则应抛出异常，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>news = News()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>news.title</span><br><span class="line"><span class="string">''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>news.title = <span class="string">"The quick brown fox."</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>news.title</span><br><span class="line"><span class="string">'THE QUICK BROWN FOX.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>news.publish_time = <span class="number">1508941663</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>news.publish_time</span><br><span class="line"><span class="number">1508941663</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>news.publish_time = <span class="string">"20171025"</span></span><br><span class="line">TypeError: Proprety [publish_time] need type of &lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt; <span class="title">but</span> <span class="title">get</span> &lt;<span class="title">class</span> '<span class="title">str</span>'&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="0x02-偷梁换柱"><a href="#0x02-偷梁换柱" class="headerlink" title="0x02 偷梁换柱"></a>0x02 偷梁换柱</h1><p>在<a href="http://blog.jobbole.com/21351/" target="_blank" rel="noopener">《深刻理解Python中的元类》</a>(<a href="https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python" target="_blank" rel="noopener">原文</a>)这篇参考文献中提到，元类做的事情可以归纳为：</p>
<ul>
<li>拦截类的创建</li>
<li>修改类</li>
<li>返回修改之后的类</li>
</ul>
<p>这不就是偷梁换柱嘛。我们来看看元类偷梁换柱的例子。为了有一个直观的理解，我们仍然先不给出背后实现的代码，而是观察最终暴露出来的特性。请看下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>news = News()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(news.title))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(type<span class="params">(news.publish_time)</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">int</span>'&gt;</span></span><br></pre></td></tr></table></figure>

<p>从之前<code>News</code>类的定义可以知道，<code>News</code>类的四个成员（title、content、publisher、publish_time）都是<code>SmartAttrDesc</code>类的实例，但是<code>News</code>类的实例中，上述四个成员的类型分别变成了对应的str和int型。</p>
<p><code>News</code>类被修改了！！！</p>
<p>这只偷梁换柱修改<code>News</code>类的幕后黑手是什么东西？—— Metaclass ！</p>
<h1 id="0x03-小开脑洞"><a href="#0x03-小开脑洞" class="headerlink" title="0x03 小开脑洞"></a>0x03 小开脑洞</h1><p>来一个小热身，请问下列一行代码的含义是什么？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo = Foo()</span><br></pre></td></tr></table></figure>

<p>对于上述代码，大家的第一反应肯定是这样的：有一个名叫<code>Foo</code>的类，我们创建了<code>Foo</code>类的一个实例，并且将这个新创建出来的实例绑定到变量<code>foo</code>上面。一般我们会称<code>foo</code>为一个对象，<code>foo</code>可以有自己的属性，自己的方法。That’s easy!</p>
<p>现在，让我们把脑洞开大一些。在Python中，一切事物都是对象，所以类也是一种对象。换句话说，类也可能是被实例化出来的。那么在上述代码中，<code>foo</code>是否可以代表一个类，而<code>Foo</code>是<strong><em>用来生成一个类的类</em></strong> 呢？</p>
<p>用下面的代码来说明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下代码遵循PEP8推荐的命名规范，类的名称使用大写字母开头，实例使用小写字母。</span></span><br><span class="line"><span class="comment"># Bar虽然是Foo的实例，但由于Bar仍然是一个类，所以Bar使用大写字母开头。</span></span><br><span class="line">Bar = Foo()</span><br><span class="line">bar = Bar()</span><br></pre></td></tr></table></figure>

<p>请打开你的脑洞：在这里，<code>Foo</code>是一个类；<code>Bar</code>是<code>Foo</code>的实例，但是<code>Bar</code>不是一个普通的实例，因为<code>Bar</code>本身也是一个类，<code>Bar</code>这个类原本不存在，它是由<code>Foo</code>在运行过程中动态创建出来的一个类；<code>bar</code>是<code>Bar</code>的实例。<br>于是，我们可以说，<code>Foo</code>类是<code>Bar</code>类的类，这里的<code>Foo</code>类就是<code>Bar</code>类的<strong><em>元类</em></strong>， 元类就是类的类，类就是元类的实例。</p>
<h1 id="0x04-冷静一下"><a href="#0x04-冷静一下" class="headerlink" title="0x04 冷静一下"></a>0x04 冷静一下</h1><p>看完上面拗口的描述，或多或少会有些懵。那么，先忘记元类这个东西，看点我们熟悉的，冷静一下。</p>
<p>看下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(a))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(a.__class__)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">int</span>'&gt;</span></span><br></pre></td></tr></table></figure>

<p>Python中每个实例都有一个__class__属性,这个属性表明了当前的这个对象是由哪个类实例化而来的。同时Python中也有一个函数<code>type()</code>可以用来检测一个实例是哪个类实例化出来的，一般而言，type(a)会返回a.__class__。<br>由于Python中任何事物都是对象，哪怕是对于最简单的数字来说都不例外，所以对于上述代码而言，变量<code>a</code>中所存储的数字<code>1</code>是<code>int</code>类的一个实例。</p>
<p>再看下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">foo = Foo()</span><br><span class="line">print(type(foo))</span><br></pre></td></tr></table></figure>

<p>上述代码的输出值为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;__main__.Foo&apos;&gt;</span><br></pre></td></tr></table></figure>

<p>即表明这里的<code>foo</code>变量是<code>Foo</code>类的实例。这太正常了，不是吗？有什么好说的呢？但是，如果我们运行下面的代码，输出会是什么呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">print(type(Foo))</span><br><span class="line">print(Foo.__class__)</span><br></pre></td></tr></table></figure>

<p>可以看到，上述代码的运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;type&apos;&gt;</span><br><span class="line">&lt;class &apos;type&apos;&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>Foo</code>是我们自己定义的一个类，并且这个类本身具有__class__属性，这就说明，我们定义的这个<code>Foo</code>类实际上是一个实例，它对应着一个叫做<code>type</code>的类，这个<code>Foo</code>类是<code>type</code>类的一个实例。这个<code>type</code>类是何方神圣？</p>
<p>回想前面元类的定义，我们定义了<code>Foo</code>类，结果发现<code>Foo</code>是一个叫做<code>type</code>的类的实例，那就说明，这个<code>type</code>类是一个元类，用<code>type</code>可以创造新的类！</p>
<h1 id="0x05-type的历史"><a href="#0x05-type的历史" class="headerlink" title="0x05 type的历史"></a>0x05 type的历史</h1><p>由于历史原因，<code>type</code>关键字在Python中有两种完全不同的含义,<a href="https://docs.python.org/3/library/functions.html?highlight=type#type" target="_blank" rel="noopener">Python文档</a>中对type关键字也有详细说明。</p>
<ul>
<li>当type后面只有一个参数时，type是一个内置函数，用来返回一个对象所属的类</li>
<li>当type后面有3个参数时，type代表一个类，这个类在初始化时接受3个参数，并且返回一个新的type类的实例,实质上就是动态定义了一个类。</li>
</ul>
<p>上述第一种情况，我们已经使用多次，不再赘述，现在重点看一下第二种形式。当传递给<code>type</code>三个参数时，三个参数分别是：</p>
<ul>
<li>name: 一个字符串，要动态创建的类的名字，这个参数会成为新创建的类的__name__属性</li>
<li>bases: 一个tuple，要动态创建的类的基类列表，这个参数会成为新类的__bases__属性</li>
<li>dict: 一个字典，要创建出来的类的具体内容，该字典的内容最后会成为新类的__dict__属性</li>
</ul>
<p>Let’s paly with <code>type</code>!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">print(Foo)</span><br><span class="line">print(type(Foo))</span><br><span class="line"></span><br><span class="line">Bar = type(<span class="string">"Bar"</span>, tuple(), &#123;&#125;)</span><br><span class="line">print(Bar)</span><br><span class="line">print(type(Bar))</span><br></pre></td></tr></table></figure>

<p>上述代码输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;__main__.Foo&apos;&gt;</span><br><span class="line">&lt;class &apos;type&apos;&gt;</span><br><span class="line">&lt;class &apos;__main__.Bar&apos;&gt;</span><br><span class="line">&lt;class &apos;type&apos;&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到，两种形式分别定义了两个类，这两个类几乎完全一样，单纯从输出结果根本无法判断哪个类是用class关键字定义的，哪个类是用type动态生成的。<br>让我们继续。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_in_base</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am a func of Base"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_in_subclass</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am a func of subclass, my name is %s"</span> % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_function_out_of_class</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normal_function_out_of_class</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"I am a func of subclass, my name is %s"</span> % self.name)</span><br><span class="line"></span><br><span class="line">Bar = type(<span class="string">"Bar"</span>, (Base,), &#123;<span class="string">"__init__"</span>: init_function_out_of_class,</span><br><span class="line">                            <span class="string">"func_in_subclass"</span>: normal_function_out_of_class&#125;)</span><br><span class="line"></span><br><span class="line">foo = Foo(<span class="string">"Myrfy"</span>)</span><br><span class="line">foo.func_in_base()</span><br><span class="line">foo.func_in_subclass()</span><br><span class="line">print(type(foo))</span><br><span class="line">print(type(Foo))</span><br><span class="line"></span><br><span class="line">bar = Bar(<span class="string">"Myrfy"</span>)</span><br><span class="line">bar.func_in_base()</span><br><span class="line">bar.func_in_subclass()</span><br><span class="line">print(type(bar))</span><br><span class="line">print(type(Bar))</span><br></pre></td></tr></table></figure>

<p>上述代码的输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">I am a func of Base</span><br><span class="line">I am a func of subclass, my name is Myrfy</span><br><span class="line">&lt;class &apos;__main__.Foo&apos;&gt;</span><br><span class="line">&lt;class &apos;type&apos;&gt;</span><br><span class="line">I am a func of Base</span><br><span class="line">I am a func of subclass, my name is Myrfy</span><br><span class="line">&lt;class &apos;__main__.Bar&apos;&gt;</span><br><span class="line">&lt;class &apos;type&apos;&gt;</span><br></pre></td></tr></table></figure>

<p>是不是很神奇？在第6<del>11行，我们采用传统的方法定义了一个<code>Foo</code>类；在第14</del>20行，又用动态创建类的方法创建了<code>Bar</code>类。<code>Bar</code>类和<code>Foo</code>类除名称不同以外，在继承和方法上的表现完全一样。<br>现在请注意上述输出的第8行。由于<code>Bar</code>类是使用<code>type</code>创建出来的，稍微回忆一下之前元类的概念，我们说类是元类的实例，那么在上面的例子里面，<code>type</code>是一个元类，我们实例化了一个<code>type</code>元类从而得到了一个叫做<code>Bar</code>的类，所以上述输出的第8行表明<code>Bar</code>的类型是<code>type</code>，也就是<code>Bar</code>是由<code>type</code>元类创建的。<br>但是……为什么第4行的输出和第8行相同？为什么我们使用class关键字定义的类也是<code>type</code>类的实例？</p>
<h1 id="0x06-类是怎么创建出来的？"><a href="#0x06-类是怎么创建出来的？" class="headerlink" title="0x06 类是怎么创建出来的？"></a>0x06 类是怎么创建出来的？</h1><p>Python中的一切类都是由<code>type</code>创建出来的！！！<br>为了理解这个过程，我们需要看看Python解释器在逐行执行Python代码的时候究竟做了什么。以下列代码为例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_in_subclass</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am a func of subclass, my name is %s"</span> % self.name)</span><br></pre></td></tr></table></figure>

<p>先来看一个简化版本，更细节的操作会在下文提到。<br>当Python解释器遇到上述第1行后，首先看到了class关键字，于是解释器知道了我们要定义一个类，再往后看，解释器得知类的名字应该叫做Foo，再往后看，解释器发现这个类有一个父类，叫做Base。于是在第一行处理完毕后，解释器得到了两个信息：name和bases，即上文传入<code>type</code>的前两个参数。<br>随后，解释器会创建一个空的字典，准备存储class body的有关信息，该字典将会成为传入<code>type</code>的第三个参数。解释器继续读入上述代码的第2行，得知有一个叫做_<em>init_<em>的函数，于是解释器继续向下读入__init__的body的代码，创建出一个<em>函数对象</em>(function object)，然后将其插入刚才创建的字典中，取名为”__init\</em></em>“。 同样的，解释器继续向下，创建func_in_subclass对应的函数对象并将其插入字典。</p>
<blockquote>
<p>函数在Python中也是一种对象，函数对象内存储了函数的名称、所属的模块以及对应的指令字节码等信息。当Python解释器遇到def关键字时，会在内存中创建对应的函数对象，并把函数体内的代码转换为Python字节码存储在函数对象中。</p>
</blockquote>
<p>至此，调用<code>type</code>来创建一个类所需的材料都已经准备好了，Python解释器会调用<code>type</code>来创建出来名为<code>Foo</code>，基类为<code>Base</code>，并且具有__init__和func_in_subclass两个方法的类。</p>
<p>所以，这里出现了一个令人震惊的真像：<code>type</code>类是Python中所有类的元类。平时，我们没有注意到<code>type</code>的存在，是因为Python解释器将<code>type</code>作为默认的元类。</p>
<h2 id="关于type的一些说明"><a href="#关于type的一些说明" class="headerlink" title="关于type的一些说明"></a>关于type的一些说明</h2><p><code>type</code>是Python中很特殊的一个东西，同时也是很基础的东西：Python中用户定义的一切类最终都是通过<code>type</code>来创建的。<br><code>type</code>之所以可以有如此强大的法力，是因为对<code>type</code>的调用会导致对<code>type</code>类的__new__方法的调用，而该方法直接对应着Python解释器<a href="https://github.com/python/cpython/blob/19f68301a1295a9c30d9f28b8f1479cdcccd75aa/Objects/typeobject.c#L2326" target="_blank" rel="noopener">C语言代码</a>中的一段程序，这段程序的作用是创建一个新的类型。凡是在Python语言中创建新类型的操作（也就是定义一个类），其最终都会转变为对解释器中相应代码段的调用，从而在内存中分配存储新类型的空间，创建新的结构体用来表示新创建的类型等等。<br><code>type</code>在Python中会有一些特殊表现是其他任何Python类无法具备的，例如<code>type</code>类的元类是<code>type</code>本身。这是写在Python解释器代码里的一段特殊逻辑，除<code>type</code>类以外，没有任何类的元类是它自己。</p>
<p>用幽默一点的话来说就是，<code>type</code>类有强大的靠山，它的实现逻辑是直接写死在解释器的代码中的！所以<code>type</code>可以实现一些其他类所不能实现的东西。</p>
<h1 id="0x07-自定义元类"><a href="#0x07-自定义元类" class="headerlink" title="0x07 自定义元类"></a>0x07 自定义元类</h1><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>上一节中我们提到<code>type</code>是Python中默认的元类，既然有默认的，那就可以有非默认的。在Python中，如果想创建一个自定义的元类，只需要继承<code>type</code>类即可。为了使用自定义的元类，需要在定义类时指定metaclass关键字。下面是最基本的例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过继承type类来创建自己的元类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过指定metaclass参数来指定使用哪个元类来创建当前正在定义的这个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(metaclass=FooMeta)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(type(FooMeta))</span><br><span class="line">print(type(Foo))</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;type&apos;&gt;</span><br><span class="line">&lt;class &apos;__main__.FooMeta&apos;&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到此时<code>Foo</code>类的类是<code>__main__.FooMeta</code>而不是<code>type</code>，说明我们的<code>Foo</code>类是使用<code>FooMeta</code>元类创建出来的。需要注意的是，元类<code>FooMeta</code>本身只是一个继承了<code>type</code>的普通的类，因此<code>FooMeta</code>的元类还是<code>type</code>。总之归根到底，一切类都可以向上追溯到<code>type</code>类。任何一个类的创建，归根结底都要转换为对python解释器中有关<code>type</code>实现的代码的调用。</p>
<blockquote>
<p>注意，Python2 不支持<code>metaclass=FooMeta</code>的写法，需要在函数体中书写<code>__metaclass__ = FooMeta</code>，详细内容请参考Python2的官方文档。</p>
</blockquote>
<h2 id="继续【偷梁换柱】"><a href="#继续【偷梁换柱】" class="headerlink" title="继续【偷梁换柱】"></a>继续【偷梁换柱】</h2><p>前文书提到元类干的“勾当”基本上来讲就是偷梁换柱，偷梁换柱是通过元类的__new__方法来实现的。作为元类的__new__方法的签名一般是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, cls_name, cls_parents, cls_attrs)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>上面的4个参数并不难理解。首先，对于任何类来讲，__new__都是一个classmethod，因此上述定义中的第一项cls与其他classmethod一样，用来表示当前类。<br>还记得前文中<code>type</code>在调用时需要传进去三个参数吗？这三个参数就是给<code>type</code>类的__new__方法使用的。因为我们自定义的元类是继承自<code>type</code>类，因此我们复写__new__的时候需要保留这三个参数。</p>
<p>有了上面的理论基础，我们开始第一次偷梁换柱！（这次是只偷不换，嘿嘿~）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, cls_name, cls_parents, cls_attrs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, cls_name, cls_parents, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(metaclass=FooMeta)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line">foo = Foo()</span><br><span class="line">foo.hello()</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &apos;Foo&apos; object has no attribute &apos;hello&apos;</span><br></pre></td></tr></table></figure>

<p>哈哈，我们成功偷走了<code>Foo</code>类的hello()方法！下面我们来详细解释一下背后发生的事情。</p>
<ol>
<li>解释器读取上述第1~3行代码，了解到用户想定义一个名字叫做FooMeta、父类是<code>type</code>，并且具有一个叫做_<em>new_<em>方法的类，于是Python解释器准备了一个字符串”FooMeta”、一个元组(type,)、一个函数对象__new\</em></em>,以及一个字典{“_<em>new_</em>“:_<em>new_</em>},然后使用<code>type</code>作为元类，传入上述准备好的参数，创建出来了一个名为<code>FooMeta</code>的类，这个类除了继承<code>type</code>类以外，和其他普通的类没啥区别。</li>
<li>解释器继续读取第5~7行代码，在读取第5行时，解释器准备了一个字符串”Foo”，一个空的元组tuple()。此外，解释器还发现这里有一个metaclass关键字，于是解释器在小本本上记下来：这个类要用<code>FooMeta</code>来创建，而不是使用<code>type</code>来创建。然后解释器照常读取第6、7行，创建函数对象hello,并构建了一个字典{“hello”:hello}</li>
<li>解释器将上述准备好的材料翻译成这句话：<code>Foo = FooMeta(&quot;Foo&quot;, tuple(), {&quot;hello&quot;:hello})</code>，然后执行它。这句话的意思很明显：创建一个<code>FooMeta</code>类的实例</li>
<li><code>FooMeta</code>的__new__方法在创建新实例的过程中被调用，于是我们继续调用父类（也就是拥有强大靠山的<code>type</code>类）的__new__方法，唯一不同的是在这次对父类方法的调用中，代表类内部结构的字典被换成了空字典。由于Metaclass这个黑魔法是要创建一个新的类型出来，正如上文中提到的，最核心的操作还是背后的老大完成的。所以这里要向上调用<code>type</code>类的__new__方法。前文曾提到过，任何一个类的创建，归根结底都要转换为对<code>type</code>背后的C程序代码的调用。</li>
<li><code>FooMeta</code>的__new__方法返回了一个新的类，这个类随后被赋值给一个叫做<code>Foo</code>的变量，也就是上述代码中定义的<code>Foo</code>类。只是……这个<code>Foo</code>类没有之前定义的函数了。</li>
</ol>
<p>现在，让我们重新看一下下面这段代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(metaclass=FooMeta)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure>

<p>当你在一段Python源码中看到上面这样的类定义时，心里要知道，我看到的这3行代码只是给元类的素材而已，上面三行代码提供了类名、父类、类内部成员这三种素材，然后这些素材被交给元类去处理。元类可能返回一个和输入素材一模一样的类（使用默认的<code>type</code>作为元类），也可能返回一个被修改的面目全非的类(使用自定义元类来创建类，就上上面这样)。在我们的上一个例子中，真实获得的类是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Foo(metaclass=FooMeta):      元类        class Foo():</span><br><span class="line">    def hello(self):              ======&gt;          pass</span><br><span class="line">        print(&quot;hello&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="加深印象"><a href="#加深印象" class="headerlink" title="加深印象"></a>加深印象</h2><p>上述演示了使用元类删除一个类方法的例子，为了大家更好的接触一下元类，我们再来试试替换和增加方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_normal_function_out_of_class</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    print(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">another_function_out_of_class</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"A World That Has Been Modified By Metaclass"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, cls_name, cls_parents, cls_attrs)</span>:</span></span><br><span class="line">        <span class="comment"># add a new method to class</span></span><br><span class="line">        cls_attrs[<span class="string">"print_name"</span>] = a_normal_function_out_of_class</span><br><span class="line">        <span class="comment"># replace a method</span></span><br><span class="line">        cls_attrs[<span class="string">"world"</span>] = another_function_out_of_class</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, cls_name, cls_parents, cls_attrs)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(metaclass=FooMeta)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Hello"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">world</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">" world"</span>)</span><br><span class="line"></span><br><span class="line">foo = Foo()</span><br><span class="line">foo.hello()</span><br><span class="line">foo.print_name(<span class="string">"Myrfy"</span>)</span><br><span class="line">foo.world()</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">Myrfy</span><br><span class="line">A World That Has Been Modified By Metaclass</span><br></pre></td></tr></table></figure>

<p>通过修改上面的<code>cls_attrs</code>字典，我们就几乎完全掌握了一个类的创建过程。</p>
<p>这就是元类！</p>
<h1 id="0x08-一人得道，惠及子孙"><a href="#0x08-一人得道，惠及子孙" class="headerlink" title="0x08 一人得道，惠及子孙"></a>0x08 一人得道，惠及子孙</h1><p>请看下列代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class FooMeta(type):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class Foo(metaclass=FooMeta):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class Bar(Foo):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class Baz(Bar):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">print(type(Baz))</span><br></pre></td></tr></table></figure>

<p>猜猜上面代码的输出是什么？答案是<code>&lt;class &#39;__main__.FooMeta&#39;&gt;</code>。<br>Python解释器会逐级向上查找各个父类，看看他们有没有指定元类，只要有前辈指定了元类，那么这个类也会使用前辈指定的元类来创建。只有这个类的各个父类都没有指定元类时，Python才会用默认的<code>type</code>作为元类。这样做带来的好处就是，不必在每个子类中显式指定元类是什么。例如你在书写一个框架，肯定不希望使用者在每次定义一个类时还要显式指定metaclass=XXXX。这时，只要定义一个类，指定好metaclass,然后让别的类继承就好了。</p>
<h1 id="0x09-回到主题"><a href="#0x09-回到主题" class="headerlink" title="0x09 回到主题"></a>0x09 回到主题</h1><p>有了上面的理论基础，现在可以开始正式编写我们的“智能属性”框架了。下面首先给出整个框架的完整代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Myrfy (https://www.github.com/myrfy001)</span></span><br><span class="line"><span class="comment"># License: MIT </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartAttrDesc</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_set_wrapper</span><span class="params">(attr_name)</span>:</span></span><br><span class="line">    <span class="comment"># Use the closure to save the attr name</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fget</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._attr_values[attr_name]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fset</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        attr_meta = self._attr_meta[attr_name]</span><br><span class="line">        type_ = attr_meta.get(<span class="string">"type_"</span>)</span><br><span class="line">        <span class="keyword">if</span> type_ <span class="keyword">and</span> <span class="keyword">not</span> isinstance(val, type_):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">"Proprety [&#123;&#125;] need type of &#123;&#125; but get &#123;&#125;"</span>.format(</span><br><span class="line">                attr_name, type_, type(val)))</span><br><span class="line"></span><br><span class="line">        func = attr_meta.get(<span class="string">"func"</span>)</span><br><span class="line">        <span class="keyword">if</span> func:</span><br><span class="line">            val = func(val)</span><br><span class="line">        self._attr_values[attr_name] = val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fget, fset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartAttrMetaclass</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, cls_name, cls_parents, cls_attrs)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># only type of SmartAttrDesc will became a smart attr</span></span><br><span class="line">        _attr_meta = &#123;name: val <span class="keyword">for</span> name, val <span class="keyword">in</span> cls_attrs.items()</span><br><span class="line">                      <span class="keyword">if</span> isinstance(val, SmartAttrDesc)&#125;</span><br><span class="line">        cls_attrs[<span class="string">"_attr_meta"</span>] = _attr_meta</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Override propreties</span></span><br><span class="line">        <span class="keyword">for</span> attr_name <span class="keyword">in</span> _attr_meta:</span><br><span class="line">            cls_attrs[attr_name] = property(*get_set_wrapper(attr_name))</span><br><span class="line"></span><br><span class="line">        new_cls = type.__new__(cls, cls_name, cls_parents, cls_attrs)</span><br><span class="line">        <span class="keyword">return</span> new_cls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartAttrBase</span><span class="params">(metaclass=SmartAttrMetaclass)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls)</span>:</span></span><br><span class="line">        new_inst = object.__new__(cls)</span><br><span class="line">        new_inst._attr_values = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> attr_name, attr_meta <span class="keyword">in</span> cls._attr_meta.items():</span><br><span class="line">            setattr(new_inst, attr_name,  attr_meta.get(<span class="string">"default"</span>))</span><br><span class="line">        <span class="keyword">return</span> new_inst</span><br></pre></td></tr></table></figure>

<h2 id="“智能属性”描述类"><a href="#“智能属性”描述类" class="headerlink" title="“智能属性”描述类"></a>“智能属性”描述类</h2><p>代码的第3~4行实现了用来描述一个“智能属性”特征的<code>SmartAttrDesc</code>类。从文章开头的示例代码和名称不难看出这个类的作用是描述一个属性，该类在初始化时接受不定参数用来描述该属性的特征，并将特征保存起来。可以看出其作用与初始化形式均与python中的dict类非常相似，于是采用拿来主义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartAttrDesc</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>这里不能直接用dict吗？其实也可以，不过呢，重新起一个名字可以具有更好的可读性。此外，后文中的元类会判断一个类成员是不是<code>SmartAttrDesc</code>的实例，只有类成员是<code>SmartAttrDesc</code>时，元类才会将其替换成对应的属性类型，如果直接使用dict，则可能导致元类修改了他不该修改的成员。</p>
<h2 id="SmartAttrMetaclass概述"><a href="#SmartAttrMetaclass概述" class="headerlink" title="SmartAttrMetaclass概述"></a>SmartAttrMetaclass概述</h2><p>代码的第27<del>40行定义了<code>SmartAttrMetaclass</code>元类。<br>在31</del>32行，我们创建了一个名为<code>_attr_meta</code>的字典，用来保存待创建的类中所有“智能属性”的描述信息。在这里使用了isinstance函数来筛选出所有的<code>SmartAttrDesc</code>实例。<br>在第33行，我们将刚才生成的<code>_attr_meta</code>字典放入到将要创建的类中，这样，由该元类创建的类将包含一个<code>_attr_meta</code>属性，内部存储了原来定义的所有“智能属性”的描述信息。<br>第36~37行，原来类中定义的<code>SmartAttrMetaclass</code>类型的成员被替换为由property函数生成的属性成员，最终创建的类中将不包含<code>SmartAttrMetaclass</code>类型的成员。</p>
<h2 id="fget和fset函数的实现"><a href="#fget和fset函数的实现" class="headerlink" title="fget和fset函数的实现"></a>fget和fset函数的实现</h2><p>代码第9~22定义了传递给<code>property</code>函数的<code>fget</code>和<code>fset</code>函数，在<code>fget</code>函数比较简单，只是返回属性的值，而<code>fset</code>函数则根据之前创建的<code>_attr_meta</code>类属性中保存的规则来进行校验，若尝试赋给属性的值不合法则会抛出异常。<br>代码中出现的<code>_attr_values</code>属性是在类实例化时设置的一个字典，用来保存各个属性的属性值，下文再详细介绍。</p>
<p>需要注意的是，我们书写的<code>fget</code>和<code>fset</code>函数需要应对不同的属性，因此我们需要知道是对哪个属性的访问操作触发了<code>fget</code>或者<code>fset</code>。很不幸的是，<code>property</code>函数所接收的<code>fget</code>和<code>fset</code>函数的签名并不包含当前被调用的属性的名字。所以我们需要想办法把属性的名字与<code>fget</code>和<code>fset</code>函数绑定到一起。这个工作可以通过<code>functools.partial</code>来实现，也可以通过自己通过闭包来实现，这里选择第二种方式，可以看到代码的第9~22是写在第7行定义的<code>get_set_wrapper</code>函数中。</p>
<h2 id="SmartAttrBase类的实现"><a href="#SmartAttrBase类的实现" class="headerlink" title="SmartAttrBase类的实现"></a>SmartAttrBase类的实现</h2><p>第43~49行定义了<code>SmartAttrBase</code>类，可以明显看到，该类指定了元类，因此所有继承自该类的子类都会使用<code>SmartAttrMetaclass</code>作为元类。<br>在这里，我们重写了<code>SmartAttrBase</code>类的<code>__init__</code>方法，其目的是为新创建出来的实例创建<code>_attr_values</code>成员（一个字典），并将各个属性的默认值存入其中。<code>fget</code>和<code>fset</code>也会读写其中的值。</p>
<h1 id="0x0A-结语"><a href="#0x0A-结语" class="headerlink" title="0x0A 结语"></a>0x0A 结语</h1><p>以上是笔者学习Python Metaclass的过程中所了解到的一些原理性质的东西，并通过一个不到50行但很实用的小例子展示了Python中元类的用法。由于笔者水平有限，如有错误，请到<a href="https://github.com/myrfy001/blog.ideawand.com" target="_blank" rel="noopener">https://github.com/myrfy001/blog.ideawand.com</a>提出Issue, 我会尽快改正。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="http://blog.jobbole.com/21351/" target="_blank" rel="noopener">《深刻理解Python中的元类》</a>(<a href="https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python" target="_blank" rel="noopener">原文</a>)</li>
<li><a href="https://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/" target="_blank" rel="noopener">Understanding Python metaclasses</a></li>
<li><a href="https://eli.thegreenplace.net/2012/06/15/under-the-hood-of-python-class-definitions" target="_blank" rel="noopener">Under the hood of Python class definitions</a></li>
<li><a href="https://stackoverflow.com/questions/47006895/the-built-in-keyword-type-means-a-function-or-a-class-in-python" target="_blank" rel="noopener">The built-in keyword type means a function or a class in python?</a></li>
<li><a href="https://docs.python.org/3/library/functions.html?highlight=type#type" target="_blank" rel="noopener">Python文档关于type的描述</a></li>
</ul>

    </div>

    
    
    <img src="/images/qrcode_for_gh_d3fcb061f2e4_258.jpg" width="25%" height="25%"/>
<div align="center">
<div>合作微信公众号：极客幼稚园</div>
<div>关注阅读更多优质技术文章</div>
</div>


        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Myrfy
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://blog.ideawand.com/2017/10/25/smart-attribute-using-metaclass-in-50-lines-of-python-code/" title="Python之Metaclass元类详解与实战:50行代码实现【智能属性】">http://blog.ideawand.com/2017/10/25/smart-attribute-using-metaclass-in-50-lines-of-python-code/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/null" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-ND</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Python/" rel="tag"># Python</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2017/10/12/setup-a-js-mining-proxy/" rel="next" title="搭建自己的JavaScript挖矿代理">
                  <i class="fa fa-chevron-left"></i> 搭建自己的JavaScript挖矿代理
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2017/11/22/build-certificate-that-support-Subject-Alternative-Name-SAN/" rel="prev" title="使用OpenSSL生成含有Subject Alternative Name(SAN)的证书">
                  使用OpenSSL生成含有Subject Alternative Name(SAN)的证书 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0x00-背景"><span class="nav-number">1.</span> <span class="nav-text">0x00 背景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x01-我们的目标（没有蛀-牙Bug）"><span class="nav-number">2.</span> <span class="nav-text">0x01 我们的目标（没有蛀 牙Bug）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x02-偷梁换柱"><span class="nav-number">3.</span> <span class="nav-text">0x02 偷梁换柱</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x03-小开脑洞"><span class="nav-number">4.</span> <span class="nav-text">0x03 小开脑洞</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x04-冷静一下"><span class="nav-number">5.</span> <span class="nav-text">0x04 冷静一下</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x05-type的历史"><span class="nav-number">6.</span> <span class="nav-text">0x05 type的历史</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x06-类是怎么创建出来的？"><span class="nav-number">7.</span> <span class="nav-text">0x06 类是怎么创建出来的？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#关于type的一些说明"><span class="nav-number">7.1.</span> <span class="nav-text">关于type的一些说明</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x07-自定义元类"><span class="nav-number">8.</span> <span class="nav-text">0x07 自定义元类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#小试牛刀"><span class="nav-number">8.1.</span> <span class="nav-text">小试牛刀</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继续【偷梁换柱】"><span class="nav-number">8.2.</span> <span class="nav-text">继续【偷梁换柱】</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#加深印象"><span class="nav-number">8.3.</span> <span class="nav-text">加深印象</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x08-一人得道，惠及子孙"><span class="nav-number">9.</span> <span class="nav-text">0x08 一人得道，惠及子孙</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x09-回到主题"><span class="nav-number">10.</span> <span class="nav-text">0x09 回到主题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#“智能属性”描述类"><span class="nav-number">10.1.</span> <span class="nav-text">“智能属性”描述类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SmartAttrMetaclass概述"><span class="nav-number">10.2.</span> <span class="nav-text">SmartAttrMetaclass概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fget和fset函数的实现"><span class="nav-number">10.3.</span> <span class="nav-text">fget和fset函数的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SmartAttrBase类的实现"><span class="nav-number">10.4.</span> <span class="nav-text">SmartAttrBase类的实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x0A-结语"><span class="nav-number">11.</span> <span class="nav-text">0x0A 结语</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考文献"><span class="nav-number">12.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Myrfy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/null" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-nd.svg" alt="Creative Commons"></a>
  </div>


<img src="/images/qrcode_for_gh_d3fcb061f2e4_258.jpg" width="70%" height="70%"/>
<div>合作微信公众号：极客幼稚园</div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Myrfy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  

</body>
</html>
