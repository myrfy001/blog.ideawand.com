<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="IdeaWand" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="上一期中，我们介绍了Rust过程宏开发的基础流程，从本期开始，我们以戴维·托尔奈（David Tolnay，也就是syn和quote这两个库的作者）的教学项目proc-macro-workshop出发，带领大家实战几个Rust过程宏的编写。 proc-macro-workshop是一个包含5个过程宏的“解题游戏”，每一个过程宏都是有实际应用价值的案例，通过一系列由简到繁的测试用例，指导你去完成每一">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust过程宏系列教程(2)--实现proc-macro-workshop项目之Builder题目">
<meta property="og:url" content="http://blog.ideawand.com/2021/03/24/rust_procedural_macro/rust_proc_marco_workshop_guide-02/index.html">
<meta property="og:site_name" content="IdeaWand">
<meta property="og:description" content="上一期中，我们介绍了Rust过程宏开发的基础流程，从本期开始，我们以戴维·托尔奈（David Tolnay，也就是syn和quote这两个库的作者）的教学项目proc-macro-workshop出发，带领大家实战几个Rust过程宏的编写。 proc-macro-workshop是一个包含5个过程宏的“解题游戏”，每一个过程宏都是有实际应用价值的案例，通过一系列由简到繁的测试用例，指导你去完成每一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://blog.ideawand.com/images/rust_procedural_macro/derive_input_mapping.png">
<meta property="article:published_time" content="2021-03-24T14:09:26.000Z">
<meta property="article:modified_time" content="2021-05-05T08:34:48.000Z">
<meta property="article:author" content="Myrfy">
<meta property="article:tag" content="Rust,过程宏,proc-macro,proc-macro-workshop">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://blog.ideawand.com/images/rust_procedural_macro/derive_input_mapping.png">

<link rel="canonical" href="http://blog.ideawand.com/2021/03/24/rust_procedural_macro/rust_proc_marco_workshop_guide-02/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

<script data-ad-client="ca-pub-6889177530753831" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <title>Rust过程宏系列教程(2)--实现proc-macro-workshop项目之Builder题目 | IdeaWand</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-109133538-1"></script>
    <script>
      var host = window.location.hostname;
      if (host !== "localhost" || !true) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-109133538-1');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?bbacc323b97a99015e18a0f4ac809c48";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">IdeaWand</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">A Wand Makes Your Ideas Come True</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.ideawand.com/2021/03/24/rust_procedural_macro/rust_proc_marco_workshop_guide-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Myrfy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IdeaWand">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Rust过程宏系列教程(2)--实现proc-macro-workshop项目之Builder题目
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-24 22:09:26" itemprop="dateCreated datePublished" datetime="2021-03-24T22:09:26+08:00">2021-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-05 16:34:48" itemprop="dateModified" datetime="2021-05-05T16:34:48+08:00">2021-05-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>上一期中，我们介绍了Rust过程宏开发的基础流程，从本期开始，我们以戴维·托尔奈（David Tolnay，也就是<code>syn</code>和<code>quote</code>这两个库的作者）的教学项目<code>proc-macro-workshop</code>出发，带领大家实战几个Rust过程宏的编写。</p>
<p><code>proc-macro-workshop</code>是一个包含5个过程宏的“解题游戏”，每一个过程宏都是有实际应用价值的案例，通过一系列由简到繁的测试用例，指导你去完成每一个过程宏的开发，而我们要做的，就是编写代码，像闯关游戏一样依次通过每一个测试用例，在这个过程中，我们会学到不同类型的过程宏的开发方法。</p>
<p>好了，不废话了，准备好一台电脑，我们从第一个过程宏挑战任务<code>builder</code>开始，每一关对应的视频教程我也放在下面了，点击【阅读原文】就可以看到所有的视频教程。</p>
<p>序言视频版：</p>
<iframe src="//player.bilibili.com/player.html?aid=332284630&bvid=BV16A411N7m2&cid=316964888&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<span id="more"></span>


<p>首先克隆<a target="_blank" rel="noopener" href="https://github.com/dtolnay/proc-macro-workshop这个项目到本地，我们将在这个项目中进行开发">https://github.com/dtolnay/proc-macro-workshop这个项目到本地，我们将在这个项目中进行开发</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/blog.ideawand.com  # 进入我的工作目录</span><br><span class="line">git clone https://github.com/dtolnay/proc-macro-workshop.git</span><br></pre></td></tr></table></figure>

<p>克隆项目后，我们会得到下面这样的目录结构。回忆我们上一篇文章中提到的，声明过程宏的crate需要和使用过程宏的crate独立开，这个项目也不例外，其中，5个题目分别独立存放在5个文件夹中。而目录的最顶层定义了一个bin类型的crate，可以使用我们定义的过程宏。我们后续的一些调试工作会借助外层crate的<code>main.rs</code>来进行。每一个题目所在的crate目录中都有一个tests文件夹，里面有通过数字编号命名的测试用例，以及一个<code>progress.rs</code>文件，<code>progress.rs</code>控制了哪些测试用例是生效的，在解题闯关的过程中，每当你通过一个测试用例，你就要到<code>progress.rs</code>中开启下一个测试用例，直到通过所有的测试用例。当然啦，解题过程中每一步的提示信息，都在以数字编号开头的测试用例中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">└── blog.ideawand.com           -- 我们的工作目录</span><br><span class="line">    └── proc-macro-workshop</span><br><span class="line">        ├── bitfield            -- 虽然排在第一个，却是最难的一个，我们在最后一篇文章再去讨论它</span><br><span class="line">        │   ├── impl</span><br><span class="line">        │   ├── src</span><br><span class="line">        │   ├── tests</span><br><span class="line">        │   │   ├── &lt;省略这里的内容。。。&gt;</span><br><span class="line">        │   └── Cargo.toml</span><br><span class="line">        ├── builder             -- builder项目，我们今天的主角</span><br><span class="line">        │   ├── src</span><br><span class="line">        │   ├── tests</span><br><span class="line">        │   │   ├── 01-parse.rs</span><br><span class="line">        │   │   ├── 02-create-builder.rs</span><br><span class="line">        │   │   ├── 03-call-setters.rs</span><br><span class="line">        │   │   ├── 04-call-build.rs</span><br><span class="line">        │   │   ├── 05-method-chaining.rs</span><br><span class="line">        │   │   ├── 06-optional-field.rs</span><br><span class="line">        │   │   ├── 07-repeated-field.rs</span><br><span class="line">        │   │   ├── 08-unrecognized-attribute.rs</span><br><span class="line">        │   │   ├── 08-unrecognized-attribute.stderr</span><br><span class="line">        │   │   ├── 09-redefined-prelude-types.rs</span><br><span class="line">        │   │   └── progress.rs  -- 闯关进度控制文件，在里面决定开启哪些测试用例</span><br><span class="line">        │   └── Cargo.toml</span><br><span class="line">        ├── debug               </span><br><span class="line">        │   ├── src</span><br><span class="line">        │   ├── tests</span><br><span class="line">        │   │   ├── &lt;省略这里的内容。。。&gt;</span><br><span class="line">        │   └── Cargo.toml</span><br><span class="line">        ├── seq</span><br><span class="line">        │   ├── src</span><br><span class="line">        │   ├── tests</span><br><span class="line">        │   │   ├── &lt;省略这里的内容。。。&gt;</span><br><span class="line">        │   └── Cargo.toml</span><br><span class="line">        ├── sorted</span><br><span class="line">        │   ├── src</span><br><span class="line">        │   ├── tests</span><br><span class="line">        │   │   ├── &lt;省略这里的内容。。。&gt;</span><br><span class="line">        │   └── Cargo.toml</span><br><span class="line">        ├── Cargo.toml</span><br><span class="line">        ├── LICENSE-APACHE</span><br><span class="line">        ├── LICENSE-MIT</span><br><span class="line">        ├── README.md</span><br><span class="line">        └── main.rs            -- 外层Crate，可以在这里使用上面定义的各个过程宏，我们将通过这个文件来查看过程宏展开后生成的代码</span><br></pre></td></tr></table></figure>

<p>以上信息主要来自于<code>proc-macro-workshop</code>项目的readme文档，如果大家的英文水平还可以的话，建议阅读一下原始的文档。</p>
<p>了解完整体项目的结构后，我们开始正式挑战<code>builder</code>项目！ 首先我们需要看一下<code>builder</code>题目要实现什么功能，每一个挑战题目到实现的目标都写在了<code>proc-macro-workshop</code>的readme文档中，下面我来把和<code>builder</code>项目相关的部分大致转述一下：</p>
<ul>
<li>我们要实现一个派生宏<code>derive(Builder)</code></li>
<li>这个宏提供了一个初始化结构体的方式，其使用效果大致如下,将<code>derive(Builder)</code>宏作用于<code>Command</code>结构体以后，会根据结构体的字段，自动生成一系列方法，来为我们提供初始化结构体中每个字段的方法：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> derive_builder::Builder;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Builder)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Command</span></span> &#123;</span><br><span class="line">    executable: <span class="built_in">String</span>,</span><br><span class="line">    <span class="meta">#[builder(each = <span class="meta-string">&quot;arg&quot;</span>)]</span></span><br><span class="line">    args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">    current_dir: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> command = Command::builder()</span><br><span class="line">        .executable(<span class="string">&quot;cargo&quot;</span>.to_owned())</span><br><span class="line">        .arg(<span class="string">&quot;build&quot;</span>.to_owned())</span><br><span class="line">        .arg(<span class="string">&quot;--release&quot;</span>.to_owned())</span><br><span class="line">        .build()</span><br><span class="line">        .unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(command.executable, <span class="string">&quot;cargo&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>了解完任务目标以后，我们可以开始解题了。首先进入<code>builder</code>目录下的<code>tests</code>目录，并编辑<code>progress.rs</code>文件，将其中<code>t.pass(&quot;tests/01-parse.rs&quot;);</code>这一行的注释去掉，表示我们要检验第一个测试用例的结果是否正确。然后，我们打开<code>tests/01-parse.rs</code>这个文件，查看第一题的解题提示。</p>
<h3 id="第一关"><a href="#第一关" class="headerlink" title="第一关"></a>第一关</h3><p>第一关视频版：</p>
<iframe src="//player.bilibili.com/player.html?aid=587300512&bvid=BV1TB4y1P7ak&cid=317585480&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>


<blockquote>
<ul>
<li>这个测试检测是否定义了一个名为<code>Builder</code>的派生宏，也就是说，只要我们定义了这个宏，什么都不用做，就可以通过这一关</li>
<li>什么都不做，意味着我们只需要返回空的TokenStream即可，但是，考官建议我们额外多做一些尝试：<ul>
<li>尝试把输入的TokenStream解析为<code>syn::DeriveInput</code>这个语法树节点类型</li>
<li>阅读官方文档中关于<code>syn::DeriveInput</code>这个结构体的说明，看看其中的字段分别包含了哪些信息，对我们后续解题有什么用处。<ul>
<li>对于这个结构体的描述，我们会在第二关的闯关过程中再介绍，当然你也可以提前阅读文档</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>通过这一关的技能我们在上一篇文章中已经遇到过了，因此这一关不难，直接上代码。我们编写代码的位置是<code>builder/src/lib.rs</code>这个文件，代码如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> proc_macro::TokenStream;</span><br><span class="line"><span class="keyword">use</span> syn;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[proc_macro_derive(Builder)]</span> <span class="comment">// 注意，这里和第一篇文章里的 #[proc_macro_attribute]不同</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">derive</span></span>(input: TokenStream) -&gt; TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> st = syn::parse_macro_input!(input <span class="keyword">as</span> syn::DeriveInput);</span><br><span class="line">    TokenStream::new()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，我们使用了<code>syn</code>包的<code>parse_macro_input!</code>宏将类型为<code>proc_macro::TokenStream</code>的input解析成了<code>syn::DeriveInput</code>类型的语法树节点<code>st</code>，然后产生一个空的<code>TokenStream</code>对象，返回给编译器。</p>
<p>这里需要额外注意的一点是，上一篇入门文章中我们给出的示例是一个属性样式的过程宏，属性样式的过程宏使用<code>#[proc_macro_attribute]</code>来定义，而本篇我们编写的是一个派生样式的过程宏，派生样式的过程宏用<code>#[proc_macro_derive(XXX)]</code>的形式来定义，除此之外，还有：</p>
<ul>
<li>派生样式的过程宏，其名字不是由函数名来定义的，而是由<code>#[proc_macro_derive(XXX)]</code>中的<code>XXX</code>来定义的</li>
<li>派生样式的过程宏，其定义的函数签名只包含一个<code>TokenStream</code>输入，相当于上篇文章介绍的属性式过程宏的<code>item</code>入参，也就是说派生式的过程宏相比于属性式的过程宏，少了<code>attr</code>这个入参</li>
<li>开发派生式过程宏时，通常将输入的<code>TokenStream</code>解析为<code>syn::DeriveInput</code>，这是派生宏定义对应的语法树节点</li>
</ul>
<blockquote>
<p>其实，大家可以把派生过程宏认为是一种特殊的属性式过程宏，把属性式过程宏看成是派生式的扩展版本，能用派生式过程宏实现的，用属性式过程宏也可以实现。另外从发展时间线上来说，属性式过程宏是在2018版本中新加入的，所以它和派生式过程宏有功能重叠也是有历史原因的。</p>
</blockquote>
<blockquote>
<p>上述代码直接返回了空的<code>TokenStream</code>，而上一篇文章我们在定义属性式过程宏时曾经提到，最简单的过程宏就是对输入不做修改，原封不动返回给编译器，可是这里为什么你返回了一个空的<code>TokenStream</code>呢？这样做不是就把输入给修改了吗？ 这其实是派生式过程宏和属性式过程宏的另外一个区别，先存疑，我们会在稍后的第二关详细介绍这个问题。</p>
</blockquote>
<p>由于我们引用了<code>syn</code>和<code>quote</code>两个包，我们还需要修改一下<code>builder/cargo.toml</code>文件，将<code>dependencies</code>小节下的<code># TODO</code>替换为如下的依赖声明,<code>proc-macro2</code>包我们后面会用到，这里也先引用过来：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">syn</span> = &#123;version=<span class="string">&quot;1.0&quot;</span>, features=[<span class="string">&quot;extra-traits&quot;</span>]&#125;</span><br><span class="line"><span class="attr">proc-macro2</span> = &#123;version=<span class="string">&quot;1.0&quot;</span>&#125;</span><br><span class="line"><span class="attr">quote</span> = &#123;version=<span class="string">&quot;1.0&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>上述<code>syn</code>包额外加入的<code>extra-traits</code>特性是为了后续调试的方便。接下来，我们在<code>builder</code>目录下运行<code>cargo test</code>，不出意外，我们应该顺利通过了第一关测试。现在可以修改<code>builder/tests/progress.rs</code>文件,开启第二关的测试。</p>
<h3 id="第二关"><a href="#第二关" class="headerlink" title="第二关"></a>第二关</h3><p>第二关视频版：</p>
<iframe src="//player.bilibili.com/player.html?aid=802590935&bvid=BV1uy4y147zG&cid=322449371&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<blockquote>
<p>我们要生成一个辅助的结构体，他的命名格式为<code>&lt;结构体名称&gt;+Builder</code>，同时，我们要为原始结构体生成生成一个<code>builder</code>方法，让他返回一个辅助结构体的实例。最终要生成的代码样式如下。：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">CommandBuilder</span></span> &#123;</span><br><span class="line">    executable: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">    args: <span class="built_in">Option</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;&gt;,</span><br><span class="line">    env: <span class="built_in">Option</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;&gt;,</span><br><span class="line">    current_dir: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">impl</span> Command &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">builder</span></span>() -&gt; CommandBuilder &#123;</span><br><span class="line">        CommandBuilder &#123;</span><br><span class="line">            executable: <span class="literal">None</span>,</span><br><span class="line">            args: <span class="literal">None</span>,</span><br><span class="line">            env: <span class="literal">None</span>,</span><br><span class="line">            current_dir: <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>为了实现上面的功能，我们要用到几个个知识点，这些个知识点的其他介绍可以参考官方文档：</p>
<ul>
<li>标识符使用<code>syn::Ident</code>类型来表示</li>
<li>从<code>syn::DeriveInput</code>类型中获取原始输入结构体的标识符</li>
<li>构建出<code>CommandBuilder</code>这个新的标识符</li>
<li>从<code>syn::DeriveInput</code>类型中获取原始输入结构体各个字段的信息，比如字段名、字段的类型等信息</li>
<li>使用<code>quote</code>包中提供的<code>quote!</code>宏来按照模板生成<code>TokenStream</code>的方法</li>
</ul>
<p>首先是关于标识符的获取与构建:</p>
<ul>
<li><code>syn::DeriveInput</code>类型提供了<code>ident</code>属性，可以获取到被过程宏修饰的原始结构体的标识符对象</li>
<li><code>syn::Ident</code>类型提供了<code>to_string()</code>方法，可以将标识符转换为字符串</li>
<li><code>syn::Ident::new()</code>方法可以创建一个新的<code>syn::Ident</code>类型的变量<br>因此，我们通过下面几行代码可以构建出新的辅助结构体的名称标识符：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> struct_name_literal = st.ident.to_string();</span><br><span class="line"><span class="keyword">let</span> builder_name_literal = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;Builder&quot;</span>, struct_name_literal);</span><br><span class="line"><span class="keyword">let</span> builder_name_ident = syn::Ident::new(&amp;builder_name_literal, st.span());</span><br></pre></td></tr></table></figure>
在上面的代码中，有几点说明：</li>
<li>注意区分<code>_literal</code>和<code>_ident</code>这两类变量的命名，这是我个人的习惯，大家也可以用其他的命名方式，但要注意区分，字符串和标识符不是一种类型</li>
<li>标识符除了名字的字符串之外，还携带了它在源代码中的位置信息，也就是<code>span</code></li>
<li>上述的第三行中，在创建新的<code>Ident</code>时，将<code>st</code>的span作为新创建标识符的span，是出于这样的原因：<ul>
<li><code>span</code>信息主要用于发生编译错误时，编译器给用户指示出错误的位置</li>
<li>编译器报错时，不会展示过程宏生成的代码，而只会展示用户编写的原始文件代码</li>
<li>因此，对于我们通过过程宏产生出来的代码，应该指向用户原始代码文件中的某个位置，而不是凭空指向一个不存在的位置，否则后续一旦产生编译器报错，将会产生令人难以理解的错误提示</li>
<li>由于我们后续要生成的代码都是由用户输入的原始结构体产生的，所以将原始输入结构体的位置信息当做虚构出的标识符的位置信息，后续一旦报错，编译器显示的错误提示将指向用户原始的结构体，从而引导用户有效排查问题</li>
</ul>
</li>
</ul>
<p>构建出新的标识符后，我们就可以生成一些简单的代码了，整体的代码如下所示，在下面会详细解释：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> proc_macro::TokenStream;</span><br><span class="line"><span class="keyword">use</span> syn::&#123;<span class="keyword">self</span>, spanned::Spanned&#125;;</span><br><span class="line"><span class="keyword">use</span> quote::&#123;ToTokens, quote&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[proc_macro_derive(Builder)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">derive</span></span>(input: TokenStream) -&gt; TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> st = syn::parse_macro_input!(input <span class="keyword">as</span> syn::DeriveInput);</span><br><span class="line">    <span class="keyword">match</span> do_expand(&amp;st) &#123;</span><br><span class="line">        <span class="literal">Ok</span>(token_stream) =&gt; token_stream.into(),</span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; e.to_compile_error().into(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">do_expand</span></span>(st: &amp;syn::DeriveInput) -&gt; syn::<span class="built_in">Result</span>&lt;proc_macro2::TokenStream&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> struct_name_literal = st.ident.to_string();</span><br><span class="line">    <span class="keyword">let</span> builder_name_literal = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;Builder&quot;</span>, struct_name_literal);</span><br><span class="line">    <span class="keyword">let</span> builder_name_ident = syn::Ident::new(&amp;builder_name_literal, st.span());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> struct_ident = &amp;st.ident;  <span class="comment">// 模板代码中不可以使用`.`来访问结构体成员，所以要在模板代码外面将标识符放到一个独立的变量中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ret = quote! &#123;     <span class="comment">// ----------------------------------+</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> #<span class="title">builder_name_ident</span></span> &#123;                   <span class="comment">//   |</span></span><br><span class="line">            <span class="comment">// TODO                                             |</span></span><br><span class="line">        &#125;                                                  <span class="comment">//   |</span></span><br><span class="line">        <span class="keyword">impl</span> #struct_ident &#123;                               <span class="comment">//   |</span></span><br><span class="line">            <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">builder</span></span>() -&gt; #builder_name_ident &#123;      <span class="comment">//  被quote!宏包裹的是模板代码</span></span><br><span class="line">                #builder_name_ident&#123;                       <span class="comment">//   |</span></span><br><span class="line">                    <span class="comment">// TODO                                     | </span></span><br><span class="line">                &#125;                                          <span class="comment">//   |</span></span><br><span class="line">            &#125;                                              <span class="comment">//   |</span></span><br><span class="line">        &#125;                                                  <span class="comment">//   |</span></span><br><span class="line">    &#125;;                     <span class="comment">// ----------------------------------+</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">Ok</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>划重点:<br>首先观察上面代码的骨架，分为了两个函数，宏定义本身将TokenStream转换为语法树对象后，交给另一个函数去完成主要功能，并处理其返回结果；<code>do_expand</code>函数返回一个<code>syn::Result</code>类型的结果。这种框架模式可以使得我们在后续书写代码时方便的进行错误处理，后续的几个实验项目我们也会使用类似的骨架。</p>
</blockquote>
<p>对上面代码几个重点的说明：</p>
<ul>
<li><code>to_compile_error</code>方法是<code>syn</code>包提供的一个返回错误的方式，它会产生一个包含错误信息的<code>proc_macro2::TokenStream</code>类型的结果，将其返回给编译器后，我们就可以在编译器的输出日志中看到用波浪线标注出的错误位置以及上下文代码了。我们在后面会介绍如何产生错误信息。</li>
<li><code>quote!</code>宏可以通过模板的形式生成TokenStream,在上一篇文章中我们已经了解到，所谓的过程宏，就是返回一个加工修改后的TokenStream，而TokenStream的结构很复杂，手工来生成一层层的嵌套结构太痛苦了，所以我们就有了<code>quote!</code>宏这个工具来帮助我们把和rust语言很相近的模板语言转换为TokenStream，在模板中我们可以做变量替换。<ul>
<li><code>quote!</code>宏内部形如<code>#xxxx</code>的部分会被替换为<code>quote!</code>宏外面定义的变量所表达的语法树元素</li>
<li><code>quote!</code>宏的用法与rust内置的<code>macro_rules!</code>宏很类似，也支持重复替换等功能，区别是<code>quote!</code>里面用<code>#</code>而<code>macro_rules!</code>里面用<code>$</code></li>
</ul>
</li>
<li>代码中两个地方使用到了<code>.into()</code>，这些都是为了在<code>proc_macro::TokenStream</code>和<code>proc_macro2::TokenStream</code>类型之间转换，基本上<code>syn</code>和<code>quote</code>包产生的结果都是<code>proc_macro2::TokenStream</code>，我们的大原则就是在中间环节都用<code>proc_macro2</code>包的，只有在最终返回编译器的时候再转换成<code>proc_macro</code>包的。</li>
</ul>
<p>上述代码写完以后，我们就可以看看我们的过程宏生成的结果是什么样的了，这里我们要借助<code>cargo expand</code>这个命令来查看展开的结果，如果没有安装过这个工具，可以通过<code>cargo install cargo-expand</code>命令来安装。</p>
<p>目前我们关心的是我们编写的过程宏在第二关的测试用例中使用时，会产生什么样的效果，因此我们就以第二关的测试用例来查看展开效果，将<code>blog.ideawand.com/proc-macro-workshop/builder/tests/02-create-builder.rs</code>文件中的内容全部拷贝到<code>blog.ideawand.com/proc-macro-workshop/main.rs</code>中，覆盖原来<code>main.rs</code>中的全部内容即可，然后在<code>proc-macro-workshop</code>目录下执行<code>cargo expand</code>命令，应该可以看到下面的输出,我将过程宏生成的代码用注释标记了出来：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(prelude_import)]</span></span><br><span class="line"><span class="meta">#[prelude_import]</span></span><br><span class="line"><span class="keyword">use</span> std::prelude::v1::*;</span><br><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> std;</span><br><span class="line"><span class="keyword">use</span> derive_builder::Builder;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Command</span></span> &#123;                 <span class="comment">// --------------------+</span></span><br><span class="line">    executable: <span class="built_in">String</span>,                                  <span class="comment">// |</span></span><br><span class="line">    args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;,                                   <span class="comment">// 用户原始的代码</span></span><br><span class="line">    env: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;,                                    <span class="comment">// |</span></span><br><span class="line">    current_dir: <span class="built_in">String</span>,                                 <span class="comment">// |</span></span><br><span class="line">&#125;                                    <span class="comment">// --------------------+</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">CommandBuilder</span></span> &#123;&#125;         <span class="comment">// -----------------+</span></span><br><span class="line"><span class="keyword">impl</span> Command &#123;                                        <span class="comment">// |</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">builder</span></span>() -&gt; CommandBuilder &#123;              <span class="comment">// 由过程宏生成的代码片段</span></span><br><span class="line">        CommandBuilder &#123;&#125;                             <span class="comment">// | </span></span><br><span class="line">    &#125;                                                 <span class="comment">// |</span></span><br><span class="line">&#125;                                    <span class="comment">// -----------------+</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> builder = Command::builder();</span><br><span class="line">    <span class="keyword">let</span> _ = builder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看出，派生式过程宏会保留用户的原始输入的代码，然后把我们返回的TokenStream追加在用户原始代码的下方。它的行为和属性式过程宏是不一样的，属性式过程宏允许你修改用户的原始代码。所以，这里可以稍微纠正一下我们之前对于过程宏的描述，之前我们一直说，过程宏是把用户输入的代码做一顿处理之后，把加工处理后的代码给到编译器继续编译，但实际上，更准确的说法应该是，依照用户输入的代码信息，修改用户原始代码，<code>或生成全新的代码</code>，把修改后或<code>新生成</code>的代码返回给编译器继续编译。不同类型的过程宏赋予你操作用户代码的范围是不一样的。</p>
</blockquote>
<p>好了，开始下一步操作。我们已经生成出了新的结构体定义，但是结构体中的字段还没有定义出来，下面我们要开始遍历原始输入结构体的各个字段，获取这些字段的信息。</p>
<p>我们现在手头的输入信息只有一个类型为<code>syn::DeriveInput</code>类型的语法树节点，看起来所有的信息系都要从它里面挖掘了，为了获取输入结构体的信息，我们先看看<code>syn::DeriveInput</code>这个语法树节点是怎么定义的，它的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">DeriveInput</span></span> &#123;</span><br><span class="line">    <span class="comment">/// Attributes tagged on the whole struct or enum.</span></span><br><span class="line">    <span class="keyword">pub</span> attrs: <span class="built_in">Vec</span>&lt;Attribute&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Visibility of the struct or enum.</span></span><br><span class="line">    <span class="keyword">pub</span> vis: Visibility,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Name of the struct or enum.</span></span><br><span class="line">    <span class="keyword">pub</span> ident: Ident,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Generics required to complete the definition.</span></span><br><span class="line">    <span class="keyword">pub</span> generics: Generics,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Data within the struct or enum.</span></span><br><span class="line">    <span class="keyword">pub</span> data: Data,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先尝试自己看一下<code>syn::DeriveInput</code>的各个字段，然后尝试把他和结构体的定义联系起来。假设我们有下面这样一个结构定义,那么这里的各个语法元素和<code>syn::DeriveInput</code>中各个字段的映射关系可以用下图来表示</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Builder)]</span></span><br><span class="line"><span class="meta">#[blog.ideawand.com]</span></span><br><span class="line"><span class="meta">#[geek_kindergarten]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span> &lt;T&gt; &#123;</span><br><span class="line">    foo: T,</span><br><span class="line">    bar: <span class="built_in">i64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/rust_procedural_macro/derive_input_mapping.png" alt="deriveInput类型和结构体的对应关系"></p>
<blockquote>
<p>划重点： 通过上面的例子，要建立起一种认知，rust中各个语法元素，都可以被不同的数据结构(也就是<code>syn</code>包提供的语法树节点类型)来表示。我们上面的例子是带领大家分析了<code>syn::DeriveInput</code>结构和struct定义之间的对应关系，后续我们还会遇到各种各样的语法元素，我们不能一一给大家作图展示对应关系，这就要求大家能够自己阅读<code>syn</code>包的文档，并逐步掌握rust语言中常见语法元素与<code>syn</code>包中对应的各种数据结构。方法都是一样的，并不困难，学会多看文档。</p>
</blockquote>
<blockquote>
<p>从上面<code>DeriveInput</code>结构源代码的注释中，我们可以看到很多地方都写了<code>struct or enum</code>，也就是说，派生样式的过程宏不仅可以用在<code>struct</code>上，也可以用在<code>enum</code>上</p>
</blockquote>
<p>知道了语法树节点的结构，接下来我们就可以开始从中抽取数据了。我们现在要处理的输入结构比较简单，<code>attrs</code>和<code>generics</code>暂时都用不到，看来只要搞清楚<code>data</code>字段里的结构就行了，但是<code>data</code>节点里有什么呢？大家需要继续去继续阅读<code>syn::Data</code>数据类型的源码，一层一层去查看语法树中各种节点之间是怎样嵌套的，但语法树的嵌套层级非常灵活，你极有可能不知道写出的一段代码究竟会被解析成什么样的语法树，因此，我们可以回忆一下上一篇文章中的重点知识：</p>
<blockquote>
<ul>
<li>遇到不熟悉的语法树节点，就打印出来看看，回忆一下我们在上一篇文章中提到的重点内容：<code>print大法是开发调试rust过程宏的利器</code></li>
<li>print大法和阅读文档，要交替使用！</li>
</ul>
</blockquote>
<p>为了看看我们的原始输入结构体被解析成了什么样的语法树，我们在上述代码的<code>do_expand</code>函数开头加入一行打印语句如下所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">do_expand</span></span>(st: &amp;syn::DeriveInput) -&gt; syn::<span class="built_in">Result</span>&lt;proc_macro2::TokenStream&gt; &#123;</span><br><span class="line">    eprintln!(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, st.data);</span><br><span class="line">    <span class="comment">// 其他代码保持不变，省略。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后依然在<code>proc-macro-workshop</code>目录下,这次执行<code>cargo check</code>命令（这个命令在上一篇文章中介绍过），因为我们不需要打印过程宏展开的代码，我们只是想通过<code>check</code>命令触发宏展开的过程，执行我们的调试打印代码，这次应该会在终端中看到很长的输出，我把关键结构放在这里,删掉了一些暂时不用的字段：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Struct(</span><br><span class="line">    DataStruct &#123;</span><br><span class="line">        fields: Named(</span><br><span class="line">            FieldsNamed &#123;</span><br><span class="line">                named: [</span><br><span class="line">                    Field &#123;</span><br><span class="line">                        ident: <span class="literal">Some</span>(</span><br><span class="line">                            Ident &#123;</span><br><span class="line">                                ident: <span class="string">&quot;executable&quot;</span>,</span><br><span class="line">                                span: #<span class="number">0</span> bytes(<span class="number">1388</span>..<span class="number">1398</span>),</span><br><span class="line">                            &#125;,</span><br><span class="line">                        ),</span><br><span class="line">                        ty: Path(</span><br><span class="line">                           <span class="comment">// ...</span></span><br><span class="line">                        ),</span><br><span class="line">                    &#125;,</span><br><span class="line">                    Comma,</span><br><span class="line">                    <span class="comment">// 下面开始第二个字段的定义了，我们省略不写了</span></span><br><span class="line">                ],</span><br><span class="line">            &#125;,</span><br><span class="line">        ),</span><br><span class="line">        semi_token: <span class="literal">None</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>阅读上面的代码，我们可以看到<code>DeriveInput</code>的<code>data</code>字段是一个枚举类型，从<code>data</code>字段开始，到我们想要得到的字段列表，也就是上面结构中<code>Field</code>结构体构成的列表，中间还间隔了很多层不同的语法树节点，因此我们的下一步就是通过一顿模式匹配操作，拿到结构体字段的列表。</p>
<p>为了代码结构清晰，我们将其定义为一个独立的函数吧，像下面这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">StructFields</span></span> = syn::punctuated::Punctuated&lt;syn::Field,syn::Token!(,)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_fields_from_derive_input</span></span>(d: &amp;syn::DeriveInput) -&gt; syn::<span class="built_in">Result</span>&lt;&amp;StructFields&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> syn::Data::Struct(syn::DataStruct &#123;</span><br><span class="line">        fields: syn::Fields::Named(syn::FieldsNamed &#123; <span class="keyword">ref</span> named, .. &#125;),</span><br><span class="line">        ..</span><br><span class="line">    &#125;) = d.data&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">Ok</span>(named)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">Err</span>(syn::Error::new_spanned(d, <span class="string">&quot;Must define on a Struct, not Enum&quot;</span>.to_string()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这段代码中，语法树各个层级的嵌套关系、枚举类到底是哪一个成员等信息，是通过print大法得到的，而解析后数据类型的泛型参数，则是通过翻<code>syn</code>包的文档或者代码得到的，这里大家要Get的重点不是代码现在写成的这个样子，而是怎样去综合使用各种手段来找到解析语法树各式各样节点的方法，注意这里是<code>授之以渔</code>，不是<code>授之以鱼</code>。说实话，我在完成这些挑战的时候，有相当多的时间是在翻文档和打印调试信息，从而捋清楚如何操作这些语法树节点。如果大家观看视频版本，就可以看到我是如何一层层阅读文档源码、找出类型定义的过程了。</p>
<p>关于错误信息，我们使用了<code>syn::Error::new_spanned()</code>方法，其第一个参数用于指定错误对应的span信息，也就是编译器在打印错误信息时，要显示用户源代码中的哪一段上下文，我们在这里直接将输入的原始信息放在了这里，这样报错的时候，就会显示出有问题的结构体定义了。我们这里出于演示目的，如果上面的模式匹配和解构流程失败，就返回一个”该过程宏只能作用在结构体上`的错误，如果做得完善一些，上面的代码中其实有两个枚举类型的匹配，应该分别返回不同的错误信息，有兴趣的同学可以完善一下</p>
<p>拿到输入结构体中的字段以后，就可以开始产生<code>Builder</code>结构体的字段定义了，其实产生字段定义的方法有很多种，rust过程宏的机制就是，你最后能拼出来有效的TokenStream就行，至于你是模块化的拼接，还是流水账式的拼接，都可以。我们只能给大家演示一种写法，大家如果自己写，可以随意发挥。我们这里要给大家顺带展示一下<code>quote!</code>宏里面重复展开的用法，代码如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generate_builder_struct_fields_def</span></span>(fields: &amp;StructFields) -&gt; syn::<span class="built_in">Result</span>&lt;proc_macro2::TokenStream&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> idents:<span class="built_in">Vec</span>&lt;_&gt; = fields.iter().map(|f| &#123;&amp;f.ident&#125;).collect();</span><br><span class="line">    <span class="keyword">let</span> types:<span class="built_in">Vec</span>&lt;_&gt; = fields.iter().map(|f| &#123;&amp;f.ty&#125;).collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> token_stream = quote!&#123;</span><br><span class="line">        #(#idents: std::option::<span class="built_in">Option</span>&lt;#types&gt;),*</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="literal">Ok</span>(token_stream)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中：</p>
<ul>
<li>首先通过两次迭代输入的字段列表，分别得到<code>idents</code>和<code>types</code>这两个列表变量，由于迭代过程是保序的，所以这两个列表的长度是相等的，并且列表中相同下标位置的元素恰好是<code>(标识符，类型)</code>的一对儿数据。<ul>
<li><code>types</code>里面的每一个元素都是一个<code>&amp;syn::Type</code>类型的枚举，里面还有很深的嵌套层级，但我们现在可以把它当做一个整体（也就是一个语法树节点）来用，没必要去解析里面。</li>
</ul>
</li>
<li>在<code>quote!</code>宏中，可以使用<code>#(#var1 #var2 ... #varN ),*</code>的形式，来把一个列表中的内容展开成一组类似的代码，模板语言的详细说明请大家参阅官方文档</li>
<li><code>quote!</code>宏返回的是一个<code>proc_macro2::TokenStream</code>类型数据，<code>quote!</code>宏里面可以再次加入其它<code>quote!</code>宏产生的结果，这个用法我们马上就会看到。</li>
</ul>
<blockquote>
<p>划重点： </p>
<ul>
<li>上述代码中用到了非常常见的<code>Option</code>枚举类型，但这里使用了<code>std::option::Option</code>这种完整路径的写法。这是由于你无法预料到过程宏在什么场景下被使用，有可能过程宏展开的上下文中，用户定义了其他的<code>Option</code>类型，因此，为了保证过程宏的稳定性，请大家尽量使用绝对路径。</li>
<li>如果你在看B站视频，请一键三连，或者，至少点个赞吧~，如果你在看文字版，请关注我的微信公众号：极客幼稚园</li>
</ul>
</blockquote>
<p>上述代码在第二关的测试用例中执行后，预期会生成如下的代码片段,注意这四行代码周围并没有括号等其他语法元素的包围，它们仅仅是一些片段，后面我们要把这些片段插入到其他片段中，来组成更加复杂的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">executable: std::option::<span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">args: std::option::<span class="built_in">Option</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;&gt;,</span><br><span class="line">env: std::option::<span class="built_in">Option</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;&gt;,</span><br><span class="line">current_dir: std::option::<span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br></pre></td></tr></table></figure>


<p>准备好上述两个函数以后，我们可以修改一下之前的<code>do_expand</code>函数了，修改后的函数如下所示，新增代码在注释中标出：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">do_expand</span></span>(st: &amp;syn::DeriveInput) -&gt; syn::<span class="built_in">Result</span>&lt;proc_macro2::TokenStream&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> struct_name_literal = st.ident.to_string();</span><br><span class="line">    <span class="keyword">let</span> builder_name_literal = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;Builder&quot;</span>, struct_name_literal);</span><br><span class="line">    <span class="keyword">let</span> builder_name_ident = syn::Ident::new(&amp;builder_name_literal, st.span());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> struct_ident = &amp;st.ident;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下两行代码是新增的，调用上述新定义的两个函数</span></span><br><span class="line">    <span class="keyword">let</span> fields = get_fields_from_derive_input(st)?;</span><br><span class="line">    <span class="keyword">let</span> builder_struct_fields_def = generate_builder_struct_fields_def(fields)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ret = quote! &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> #<span class="title">builder_name_ident</span></span> &#123;</span><br><span class="line">            <span class="comment">// 下面这行代码是增增的，注意这里的用法：</span></span><br><span class="line">            <span class="comment">// 在当前这个`quote!`宏中，引用了其他`quote!`宏返回的结果</span></span><br><span class="line">            <span class="comment">// 在这里把不同的代码碎片拼接起来，就像搭积木一样</span></span><br><span class="line">            #builder_struct_fields_def</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">impl</span> #struct_ident &#123;</span><br><span class="line">            <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">builder</span></span>() -&gt; #builder_name_ident &#123;</span><br><span class="line">                #builder_name_ident&#123;</span><br><span class="line">                    <span class="comment">// TODO 后面会再写一个函数，生成这里需要的代码片段</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">Ok</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改完代码后，我们再在<code>proc-macro-workshop</code>目录下执行以下<code>cargo expand</code>，查看一下现在过程宏展开得到的代码，应该是下面这个样子,重点关注一下我们拼接出的<code>CommandBuilder</code>结构体的成员定义部分：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(prelude_import)]</span></span><br><span class="line"><span class="meta">#[prelude_import]</span></span><br><span class="line"><span class="keyword">use</span> std::prelude::v1::*;</span><br><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> std;</span><br><span class="line"><span class="keyword">use</span> derive_builder::Builder;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Command</span></span> &#123;</span><br><span class="line">    executable: <span class="built_in">String</span>,</span><br><span class="line">    args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">    env: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">    current_dir: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CommandBuilder</span></span> &#123;</span><br><span class="line">    executable: std::option::<span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">    args: std::option::<span class="built_in">Option</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;&gt;,</span><br><span class="line">    env: std::option::<span class="built_in">Option</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;&gt;,</span><br><span class="line">    current_dir: std::option::<span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Command &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">builder</span></span>() -&gt; CommandBuilder &#123;</span><br><span class="line">        CommandBuilder &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> builder = Command::builder();</span><br><span class="line">    <span class="keyword">let</span> _ = builder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们来继续产生其他代码片段，我们现在需要生成<code>builder()</code>方法中，结构体初始化的相关代码，最简单的做法就是把上面的代码简单修改一下即可，但我们前面提到过，rust过程宏的实现方法非常灵活，只要你能拼出正确的TokenStream就行，所以，这里我们采用了另外一种写法，下面的函数返回的是一个由TokenStream组成的列表，重复展开的工作留到<code>do_expand</code>函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generate_builder_struct_factory_init_clauses</span></span>(fields: &amp;StructFields) -&gt; syn::<span class="built_in">Result</span>&lt;<span class="built_in">Vec</span>&lt;proc_macro2::TokenStream&gt;&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> init_clauses: <span class="built_in">Vec</span>&lt;_&gt; = fields.iter().map(|f| &#123;</span><br><span class="line">        <span class="keyword">let</span> ident = &amp;f.ident;</span><br><span class="line">        quote!&#123;</span><br><span class="line">            #ident: std::option::<span class="built_in">Option</span>::<span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).collect();</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(init_clauses)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的，我们修改一下<code>do_expand</code>函数，改动部分用注释标出：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">do_expand</span></span>(st: &amp;syn::DeriveInput) -&gt; syn::<span class="built_in">Result</span>&lt;proc_macro2::TokenStream&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> struct_name_literal = st.ident.to_string();</span><br><span class="line">    <span class="keyword">let</span> builder_name_literal = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;Builder&quot;</span>, struct_name_literal);</span><br><span class="line">    <span class="keyword">let</span> builder_name_ident = syn::Ident::new(&amp;builder_name_literal, st.span());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> struct_ident = &amp;st.ident;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> fields = get_fields_from_derive_input(st)?;</span><br><span class="line">    <span class="keyword">let</span> builder_struct_fields_def = generate_builder_struct_fields_def(fields)?;</span><br><span class="line">    <span class="comment">// 下面这一行是新加的 </span></span><br><span class="line">    <span class="keyword">let</span> builder_struct_factory_init_clauses = generate_builder_struct_factory_init_clauses(fields)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ret = quote! &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> #<span class="title">builder_name_ident</span></span> &#123;</span><br><span class="line">            #builder_struct_fields_def</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">impl</span> #struct_ident &#123;</span><br><span class="line">            <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">builder</span></span>() -&gt; #builder_name_ident &#123;</span><br><span class="line">                #builder_name_ident&#123;</span><br><span class="line">                    <span class="comment">// 下面这一行是新加的，注意我们在这里重复展开了每一个字段</span></span><br><span class="line">                    #(#builder_struct_factory_init_clauses),*</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">Ok</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来大家可以再运行一下<code>cargo expand</code>来观察一下过程宏展开的结果，我们就不再列出来了。现在，我们看看第二关能不能通过了，确保<code>proc-macro-workshop/builder/tests/progress.rs</code>文件中对第二关的注释已经去掉,然后进入到<code>proc-macro-workshop/builder</code>目录下，执行<code>cargo test</code>，不出意外的话，第二关应该顺利通过！</p>
<h3 id="第三关"><a href="#第三关" class="headerlink" title="第三关"></a>第三关</h3><p>第三关视频版本：</p>
<iframe src="//player.bilibili.com/player.html?aid=290008560&bvid=BV1Sf4y1W7He&cid=322455034&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>请阅读<code>proc-macro-workshop/builder/tests/03-call-setters.rs</code>文件中的说明,主要就是要产生一组类似下面这种形式的代码，我们要把其中的<code>executable</code>和<code>String</code>全部动态替换掉：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">executable</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, executable: <span class="built_in">String</span>) -&gt; &amp;<span class="keyword">mut</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.executable = <span class="literal">Some</span>(executable);</span><br><span class="line">    <span class="keyword">self</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一关要实现的功能与第二关几乎完全一样，因此我就不再做其他解释了。大家可以先尝试自己编码之后，再看看我下面给出的一个参考实现。</p>
<p>在这个参考实现中，我再给大家展示一种代码片段拼接的方式，即直接通过<code>proc_macro2::TokenStream</code>类型提供的<code>extend</code>方法，把多个TokenStream串接在一起，就像字符串拼接一样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generate_setter_functions</span></span>(fields: &amp;StructFields) -&gt; syn::<span class="built_in">Result</span>&lt;proc_macro2::TokenStream&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> idents:<span class="built_in">Vec</span>&lt;_&gt; = fields.iter().map(|f| &#123;&amp;f.ident&#125;).collect();</span><br><span class="line">    <span class="keyword">let</span> types:<span class="built_in">Vec</span>&lt;_&gt; = fields.iter().map(|f| &#123;&amp;f.ty&#125;).collect();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个空的TokenStream</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> final_tokenstream = proc_macro2::TokenStream::new();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ident, type_) <span class="keyword">in</span> idents.iter().zip(types.iter()) &#123;</span><br><span class="line">        <span class="keyword">let</span> tokenstream_piece = quote!&#123;</span><br><span class="line">            <span class="function"><span class="keyword">fn</span> #<span class="title">ident</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, #ident: #type_) -&gt; &amp;<span class="keyword">mut</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.#ident = std::option::<span class="built_in">Option</span>::<span class="literal">Some</span>(#ident);</span><br><span class="line">                <span class="keyword">self</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 不断追加新的TokenStream片段到一个公共的TokenStream上</span></span><br><span class="line">        final_tokenstream.extend(tokenstream_piece);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(final_tokenstream)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">do_expand</span></span>(st: &amp;syn::DeriveInput) -&gt; syn::<span class="built_in">Result</span>&lt;proc_macro2::TokenStream&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> struct_name_literal = st.ident.to_string();</span><br><span class="line">    <span class="keyword">let</span> builder_name_literal = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;Builder&quot;</span>, struct_name_literal);</span><br><span class="line">    <span class="keyword">let</span> builder_name_ident = syn::Ident::new(&amp;builder_name_literal, st.span());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> struct_ident = &amp;st.ident;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> fields = get_fields_from_derive_input(st)?;</span><br><span class="line">    <span class="keyword">let</span> builder_struct_fields_def = generate_builder_struct_fields_def(fields)?;</span><br><span class="line">    <span class="keyword">let</span> builder_struct_factory_init_clauses = generate_builder_struct_factory_init_clauses(fields)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这一行是第三关新加的</span></span><br><span class="line">    <span class="keyword">let</span> setter_functions = generate_setter_functions(fields)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ret = quote! &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> #<span class="title">builder_name_ident</span></span> &#123;</span><br><span class="line">            #builder_struct_fields_def</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">impl</span> #struct_ident &#123;</span><br><span class="line">            <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">builder</span></span>() -&gt; #builder_name_ident &#123;</span><br><span class="line">                #builder_name_ident&#123;</span><br><span class="line">                    #(#builder_struct_factory_init_clauses),*</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这三行是第三关新加的</span></span><br><span class="line">        <span class="keyword">impl</span> #builder_name_ident &#123;</span><br><span class="line">            #setter_functions</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">Ok</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四关"><a href="#第四关" class="headerlink" title="第四关"></a>第四关</h3><p>第四、五关视频版本：</p>
<iframe src="//player.bilibili.com/player.html?aid=205229090&bvid=BV1bh411S7zV&cid=325369691&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>这一关要生成的代码比之前的复杂了不少，需要由宏来产生出一些判断逻辑，错误信息等，但是换汤不换药，本质还是生成代码片段后进行拼接。大家可以在本关中继续尝试各种写法。</p>
<p>接下来我要给出的写法中，采用了先将各个片段放入一个Vec中，然后再展开的做法，这是因为这样写以后，对于后面关卡的实现会比较容易，大家完全可以尝试其他的方式来写。</p>
<p>产生<code>build()</code>方法代码片段的示例代码如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generate_build_function</span></span>(fields: &amp;StructFields, origin_struct_ident: &amp;syn::Ident) -&gt; syn::<span class="built_in">Result</span>&lt;proc_macro2::TokenStream&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> idents:<span class="built_in">Vec</span>&lt;_&gt; = fields.iter().map(|f| &#123;&amp;f.ident&#125;).collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> checker_code_pieces = <span class="built_in">Vec</span>::new();</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..idents.len() &#123;</span><br><span class="line">        <span class="keyword">let</span> ident = idents[idx];</span><br><span class="line">        checker_code_pieces.push(quote!&#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.#ident.is_none() &#123;</span><br><span class="line">                <span class="keyword">let</span> err = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125; field missing&quot;</span>, <span class="built_in">stringify!</span>(#ident));</span><br><span class="line">                <span class="keyword">return</span> std::result::<span class="built_in">Result</span>::<span class="literal">Err</span>(err.into())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> fill_result_clauses = <span class="built_in">Vec</span>::new();</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..idents.len() &#123;</span><br><span class="line">        <span class="keyword">let</span> ident = idents[idx];</span><br><span class="line">        fill_result_clauses.push(quote!&#123;</span><br><span class="line">            #ident: <span class="keyword">self</span>.#ident.clone().unwrap()</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> token_stream = quote!&#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">build</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; std::result::<span class="built_in">Result</span>&lt;#origin_struct_ident, std::boxed::<span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt; &#123;</span><br><span class="line">            #(#checker_code_pieces)*</span><br><span class="line">                               <span class="comment">//  ^--注意，由于我们要重复的是一组if判断代码块，它们之间不需要用逗号分隔，所以这里的重复模式是`*`，而不是之前重复结构体字段时用到的`,*`</span></span><br><span class="line">            <span class="keyword">let</span> ret = #origin_struct_ident&#123;</span><br><span class="line">                #(#fill_result_clauses),*</span><br><span class="line">            &#125;;</span><br><span class="line">            std::result::<span class="built_in">Result</span>::<span class="literal">Ok</span>(ret)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="literal">Ok</span>(token_stream)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对do_expand()的修改如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">do_expand</span></span>(st: &amp;syn::DeriveInput) -&gt; syn::<span class="built_in">Result</span>&lt;proc_macro2::TokenStream&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> struct_name_literal = st.ident.to_string();</span><br><span class="line">    <span class="keyword">let</span> builder_name_literal = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;Builder&quot;</span>, struct_name_literal);</span><br><span class="line">    <span class="keyword">let</span> builder_name_ident = syn::Ident::new(&amp;builder_name_literal, st.span());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> struct_ident = &amp;st.ident;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> fields = get_fields_from_derive_input(st)?;</span><br><span class="line">    <span class="keyword">let</span> builder_struct_fields_def = generate_builder_struct_fields_def(fields)?;</span><br><span class="line">    <span class="keyword">let</span> builder_struct_factory_init_clauses = generate_builder_struct_factory_init_clauses(fields)?;</span><br><span class="line">    <span class="keyword">let</span> setter_functions = generate_setter_functions(fields)?;</span><br><span class="line">    <span class="comment">// 下面这一行是第四关新加的</span></span><br><span class="line">    <span class="keyword">let</span> generated_builder_functions = generate_build_function(fields,struct_ident)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ret = quote! &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> #<span class="title">builder_name_ident</span></span> &#123;</span><br><span class="line">            #builder_struct_fields_def</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">impl</span> #struct_ident &#123;</span><br><span class="line">            <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">builder</span></span>() -&gt; #builder_name_ident &#123;</span><br><span class="line">                #builder_name_ident&#123;</span><br><span class="line">                    #(#builder_struct_factory_init_clauses),*</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">impl</span> #builder_name_ident &#123;</span><br><span class="line">            #setter_functions</span><br><span class="line">            <span class="comment">// 下面这1行是第四关新加的</span></span><br><span class="line">            #generated_builder_functions</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">Ok</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第五关"><a href="#第五关" class="headerlink" title="第五关"></a>第五关</h3><p>看一下题目要求，好开心，我们的代码已经实现了第五关的所有功能，什么都不用做了~</p>
<h3 id="第六关"><a href="#第六关" class="headerlink" title="第六关"></a>第六关</h3><p>第六关视频版本：</p>
<iframe src="//player.bilibili.com/player.html?aid=545152453&bvid=BV1hi4y1A79p&cid=328346252&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>这一关的题目要求比较长，在其中介绍了一个rust过程宏机制的缺陷：rust的引用消解，或者说是符号解析，是在宏展开之后进行的，这也就是说，例如有如下代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::any::TypeId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> blog &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> ideawand &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">mod</span> com &#123;</span><br><span class="line">            <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">GeekKindergarten</span></span>&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> blog::ideawand::com::GeekKindergarten;</span><br><span class="line"><span class="keyword">use</span> blog::ideawand::com::GeekKindergarten <span class="keyword">as</span> MyPersonalBlog;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(TypeId::of::&lt;GeekKindergarten&gt;() == TypeId::of::&lt;blog::ideawand::com::GeekKindergarten&gt;());</span><br><span class="line">    <span class="built_in">assert!</span>(TypeId::of::&lt;MyPersonalBlog&gt;() == TypeId::of::&lt;blog::ideawand::com::GeekKindergarten&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常来说，上面代码中的<code>GeekKindergarten</code>类型，可以用完整的路径名来表示，也可以通过<code>use</code>关键字将其导入到当前上下文中，使用短名字来表示,还可以通过<code>as</code>关键字为其重命名，但它们都是同一个类型；然而在过程宏中，我们看到的TokenStream也好，还是TokenStream解析出的<code>syn</code>包中定义的语法树节点类型也好，它们都还没有经过引用消解，所以在rust的过程宏中，<code>GeekKindergarten</code>和<code>blog::ideawand::com::GeekKindergarten</code>以及<code>MyPersonalBlog</code>是不同的，或者说，我们无法判断他们是不是相同的类型。</p>
<p>第六关的题目是说，我们要识别出用户给出的结构体中，类型为<code>Option</code>类型的字段，对于这些字段，我们允许他们为None，也就是说要放宽第四关中<code>builder</code>方法的校验规则。为了简化这个题目，题目要求我们只要识别<code>Option</code>类型即可，不考虑通过<code>as</code>关键词重命名导致的不可识别问题，也不考虑其他同名的<code>Option</code>的情况。同时，第六关的提示中给出了我们要匹配<code>Option</code>枚举和泛型时可能用到的模式，如下所示,我们要查看结构体的某个字段是不是满足这个这个模式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Type::Path(             <span class="comment">// ------------------------------------------- 这个节点表示形如 `std::option::Option&lt;Vec&lt;String&gt;&gt;`这个整体</span></span><br><span class="line">    TypePath &#123;  </span><br><span class="line">        qself: <span class="literal">None</span>,</span><br><span class="line">        path: Path &#123;        <span class="comment">// --------------------------------------- 到这个节点其实也还是表示 `std::option::Option&lt;Vec&lt;String&gt;&gt;`这个整体</span></span><br><span class="line">            segments: [           <span class="comment">// --------------------------------- 这个列表表示 [std, option, Option&lt;Vec&lt;String&gt;&gt;]  这三个独立的段</span></span><br><span class="line">                PathSegment &#123;           <span class="comment">// --------------------------- 这个结构体表示每一段的具体内容，我们以最后一段`Option&lt;Vec&lt;String&gt;&gt;`为例</span></span><br><span class="line">                    ident: <span class="string">&quot;Option&quot;</span>,           <span class="comment">// -------------------- 这里表示Option这个标识符</span></span><br><span class="line">                    arguments: PathArguments::AngleBracketed(       <span class="comment">// 这个节点表示&lt;Vec&lt;String&gt;&gt;</span></span><br><span class="line">                        AngleBracketedGenericArguments &#123;</span><br><span class="line">                            args: [                                 <span class="comment">// 由于泛型参数可能是&lt;T,U,V&gt;等多个，所以这里是一个列表</span></span><br><span class="line">                                GenericArgument::Type(              <span class="comment">// 在上面的例子中，这个节点表示`Vec&lt;String&gt;`</span></span><br><span class="line">                                    ...                             <span class="comment">// 这里可以将`Vec&lt;String&gt;`按照上面的套路继续展开。。。</span></span><br><span class="line">                                ),</span><br><span class="line">                            ],</span><br><span class="line">                        &#125;,</span><br><span class="line">                    ),</span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>有了上面的模式参考，我们来写一个新的函数，用来识别上面的模式，如果一个type能匹配上面的模式，就把Option里面的泛型参数返回出来，否则返回一个None</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_optional_inner_type</span></span>(ty: &amp;syn::Type) -&gt; <span class="built_in">Option</span>&lt;&amp;syn::Type&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> syn::Type::Path(syn::TypePath &#123; <span class="keyword">ref</span> path, .. &#125;) = ty &#123;</span><br><span class="line">        <span class="comment">// 这里我们取segments的最后一节来判断是不是`Option&lt;T&gt;`，这样如果用户写的是`std:option:Option&lt;T&gt;`我们也能识别出最后的`Option&lt;T&gt;`</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(seg) = path.segments.last() &#123;</span><br><span class="line">            <span class="keyword">if</span> seg.ident == <span class="string">&quot;Option&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> syn::PathArguments::AngleBracketed(syn::AngleBracketedGenericArguments &#123;</span><br><span class="line">                    <span class="keyword">ref</span> args,</span><br><span class="line">                    ..</span><br><span class="line">                &#125;) = seg.arguments</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(syn::GenericArgument::Type(inner_ty)) = args.first() &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">Some</span>(inner_ty);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">None</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在能够判断一个field是否为<code>Option</code>以后，我们还需要对之前的几个函数都做出相应的调整，因此想通过这一关，改动还是比较大的，主要的改动包括：</p>
<ul>
<li>在创建builder对应的结构体时，<code>Option</code>类型字段要特殊处理，如果还按照原来的模板来生成，就会产生出<code>Option&lt;Option&lt;T&gt;&gt;</code>这种类型</li>
<li><code>Option&lt;T&gt;</code>类型字段的setter接受的类型应该是<code>T</code>，如果使用原来的模板，会拼接出来<code>Option&lt;T&gt;</code></li>
<li><code>builder</code>方法对于<code>Option&lt;T&gt;</code>字段的校验规则和其他字段不同</li>
</ul>
<p>下面我们来一个个修改，首先是修改<code>generate_builder_struct_fields_def()</code>这个函数，修改后如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generate_builder_struct_fields_def</span></span>(</span><br><span class="line">    fields: &amp;StructFields,</span><br><span class="line">) -&gt; syn::<span class="built_in">Result</span>&lt;proc_macro2::TokenStream&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> idents: <span class="built_in">Vec</span>&lt;_&gt; = fields.iter().map(|f| &amp;f.ident).collect();</span><br><span class="line">    <span class="comment">// 第六关，对types 变量的构建逻辑进行了调整</span></span><br><span class="line">    <span class="keyword">let</span> types: <span class="built_in">Vec</span>&lt;_&gt; = fields</span><br><span class="line">        .iter()</span><br><span class="line">        .map(|f| &#123;</span><br><span class="line">            <span class="comment">// 针对是否为`Option`类型字段，产生不同的结果</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(inner_ty) = get_optional_inner_type(&amp;f.ty) &#123;</span><br><span class="line">                quote!(std::option::<span class="built_in">Option</span>&lt;#inner_ty&gt;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> origin_ty = &amp;f.ty;</span><br><span class="line">                quote!(std::option::<span class="built_in">Option</span>&lt;#origin_ty&gt;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> token_stream = quote! &#123;</span><br><span class="line">        <span class="comment">// 下面这一行，也做了修改</span></span><br><span class="line">        #(#idents: #types),*</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="literal">Ok</span>(token_stream)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改<code>generate_setter_functions()</code>函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generate_setter_functions</span></span>(fields: &amp;StructFields) -&gt; syn::<span class="built_in">Result</span>&lt;proc_macro2::TokenStream&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> idents: <span class="built_in">Vec</span>&lt;_&gt; = fields.iter().map(|f| &amp;f.ident).collect();</span><br><span class="line">    <span class="keyword">let</span> types: <span class="built_in">Vec</span>&lt;_&gt; = fields.iter().map(|f| &amp;f.ty).collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> final_tokenstream = proc_macro2::TokenStream::new();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ident, type_) <span class="keyword">in</span> idents.iter().zip(types.iter()) &#123;</span><br><span class="line">        <span class="keyword">let</span> tokenstream_piece;</span><br><span class="line">        <span class="comment">// 第六关，对tokenstream_piece 变量的构建逻辑进行了调整</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(inner_ty) = get_optional_inner_type(type_) &#123;</span><br><span class="line">            tokenstream_piece = quote! &#123;</span><br><span class="line">                <span class="function"><span class="keyword">fn</span> #<span class="title">ident</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, #ident: #inner_ty) -&gt; &amp;<span class="keyword">mut</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">                    <span class="keyword">self</span>.#ident = std::option::<span class="built_in">Option</span>::<span class="literal">Some</span>(#ident);</span><br><span class="line">                    <span class="keyword">self</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tokenstream_piece = quote! &#123;</span><br><span class="line">                <span class="function"><span class="keyword">fn</span> #<span class="title">ident</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, #ident: #type_) -&gt; &amp;<span class="keyword">mut</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">                    <span class="keyword">self</span>.#ident = std::option::<span class="built_in">Option</span>::<span class="literal">Some</span>(#ident);</span><br><span class="line">                    <span class="keyword">self</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        final_tokenstream.extend(tokenstream_piece);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(final_tokenstream)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们对<code>generate_build_function()</code>函数进行修改：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generate_build_function</span></span>(</span><br><span class="line">    fields: &amp;StructFields,</span><br><span class="line">    origin_struct_ident: &amp;syn::Ident,</span><br><span class="line">) -&gt; syn::<span class="built_in">Result</span>&lt;proc_macro2::TokenStream&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> idents: <span class="built_in">Vec</span>&lt;_&gt; = fields.iter().map(|f| &amp;f.ident).collect();</span><br><span class="line">    <span class="comment">// 下面这一行是第六关新加的，之前没用到type相关信息，就没写下面这一行</span></span><br><span class="line">    <span class="keyword">let</span> types: <span class="built_in">Vec</span>&lt;_&gt; = fields.iter().map(|f| &amp;f.ty).collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> checker_code_pieces = <span class="built_in">Vec</span>::new();</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..idents.len() &#123;</span><br><span class="line">        <span class="keyword">let</span> ident = idents[idx];</span><br><span class="line">        <span class="comment">// 第六关修改，只对不是`Option`类型的字段生成校验逻辑</span></span><br><span class="line">        <span class="keyword">if</span> get_optional_inner_type(&amp;types[idx]).is_none() &#123;</span><br><span class="line">            checker_code_pieces.push(quote! &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">self</span>.#ident.is_none() &#123;</span><br><span class="line">                    <span class="keyword">let</span> err = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125; field missing&quot;</span>, <span class="built_in">stringify!</span>(#ident));</span><br><span class="line">                    <span class="keyword">return</span> std::result::<span class="built_in">Result</span>::<span class="literal">Err</span>(err.into())</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> fill_result_clauses = <span class="built_in">Vec</span>::new();</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..idents.len() &#123;</span><br><span class="line">        <span class="keyword">let</span> ident = idents[idx];</span><br><span class="line">        <span class="comment">// 这里需要区分`Option`类型字段和非`Option`类型字段</span></span><br><span class="line">        <span class="keyword">if</span> get_optional_inner_type(&amp;types[idx]).is_none() &#123;</span><br><span class="line">            fill_result_clauses.push(quote! &#123;</span><br><span class="line">                #ident: <span class="keyword">self</span>.#ident.clone().unwrap()</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            fill_result_clauses.push(quote! &#123;</span><br><span class="line">                #ident: <span class="keyword">self</span>.#ident.clone()</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> token_stream = quote! &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">build</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; std::result::<span class="built_in">Result</span>&lt;#origin_struct_ident, std::boxed::<span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt; &#123;</span><br><span class="line">            #(#checker_code_pieces)*</span><br><span class="line">            <span class="keyword">let</span> ret = #origin_struct_ident&#123;</span><br><span class="line">                #(#fill_result_clauses),*</span><br><span class="line">            &#125;;</span><br><span class="line">            std::result::<span class="built_in">Result</span>::<span class="literal">Ok</span>(ret)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="literal">Ok</span>(token_stream)</span><br><span class="line">&#125;</span><br><span class="line">     </span><br></pre></td></tr></table></figure>

<h3 id="第七关"><a href="#第七关" class="headerlink" title="第七关"></a>第七关</h3><p>第七关视频版本：</p>
<iframe src="//player.bilibili.com/player.html?aid=715287871&bvid=BV1eQ4y1Z7h9&cid=331167283&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>这一关会涉及到如何解析结构体中字段附加的属性信息(field attribute)，例如下面这个结构体</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Builder)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArticleAuthor</span></span> &#123;</span><br><span class="line">    Blog <span class="built_in">String</span>,</span><br><span class="line">    <span class="meta">#[geek_kindergarten(foo=bar)]</span></span><br><span class="line">    IdeaWand <span class="built_in">String</span>,</span><br><span class="line">    Com <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个结构体中，<code>#[geek_kindergarten(foo=bar)]</code>这一行就是附加在<code>IdeaWand</code>这个字段上的属性，属性的名字是<code>geek_kindergarten</code>，这里需要注意的一个重点是：</p>
<blockquote>
<ul>
<li>在派生宏中，上面这样的属性称为<code>惰性属性</code>（inert attributes），惰性属性必须指定关联一个派生过程宏，限定这个惰性属性只能在这个过程宏内使用。<br>那么，如何向编译器注册一个惰性属性的名字呢？在第七关的指导文档里有说明，简单来说，就是要在<code>#[proc_macro_derive(Builder)]</code>这个标签中添加上属性的名字，加入我们要加入一个名为<code>geek_kindergarten</code>的属性，那么就要这样写：<code>#[proc_macro_derive(Builder, attributes(geek_kindergarten))]</code></li>
</ul>
</blockquote>
<p>接下来的操作，和前几关大致一样，我们先来把要做的事情列一下：</p>
<ul>
<li>解析每个field的<code>attrs</code>字段，它是一个<code>Vec&lt;Attribute&gt;</code>类型，<code>Attribute</code>是一个我们前面没遇到过的语法树节点，我们的处理思路还是一样的，需要通过文档 + Print大法来搞清楚里面的结构</li>
<li>第六关中我们识别了<code>Option&lt;T&gt;</code>这种模式的代码，本关我们要识别<code>Vec&lt;T&gt;</code>，稍微调整一下，复用之前代码即可</li>
<li>针对是不是<code>Vec&lt;T&gt;</code>类型,以及是不是有属性标签，我们要用不同的模板来产生代码</li>
</ul>
<p>下面，我们先来看看怎么解析<code>Attribute</code>类型的语法树节点，由于这个属性标签是一个挺通用的解析需求，而且还比较灵活复杂，所以我们就多花点时间来介绍一下。为了探索他的行为，我们创建另一个极简版本的派生宏，专门用来打印<code>Attribute</code>结构的信息。同时，<code>Attribute</code>不一定是要写在结构体字段上的，我们也可以用一个属性来装饰整个结构体，所以<code>DeriveInput</code>语法树节点中就有<code>attrs</code>属性，因此我在接下来的小实验中，就不再去层层解析寻找字段上的属性了，直接用结构体的属性标签来做实验，效果都是一样的。下面，我们来搭建这个小的实验环境:</p>
<ul>
<li>在<code>proc-macro-workshop/builder/src/lib.rs</code>中，添加如下代码：  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[proc_macro_derive(ExploreAttribute)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">attribute_explore</span></span>(input: TokenStream) -&gt; TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> st = syn::parse_macro_input!(input <span class="keyword">as</span> syn::DeriveInput);</span><br><span class="line">    <span class="keyword">let</span> attr = st.attrs.first().unwrap();</span><br><span class="line">    eprintln!(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, attr);</span><br><span class="line">    proc_macro2::TokenStream::new().into()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>将<code>proc-macro-workshop/main.rs</code>中的内容清空，替换为下面的代码：  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> derive_builder::ExploreAttribute;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(ExploreAttribute)]</span></span><br><span class="line"><span class="meta">#[blog::ideawand::com(Bar)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
在<code>proc-macro-workshop</code>目录下执行<code>cargo check</code>,观察输出结果，对于上面的例子，我们得到的输出为：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Attribute &#123;</span><br><span class="line">    pound_token: Pound,</span><br><span class="line">    style: Outer,</span><br><span class="line">    bracket_token: Bracket,</span><br><span class="line">    path: Path &#123;</span><br><span class="line">        leading_colon: <span class="literal">None</span>,</span><br><span class="line">        segments: [</span><br><span class="line">            PathSegment &#123;</span><br><span class="line">                ident: Ident &#123;</span><br><span class="line">                    ident: <span class="string">&quot;blog&quot;</span>,</span><br><span class="line">                    span: #<span class="number">0</span> bytes(<span class="number">1383</span>..<span class="number">1387</span>),</span><br><span class="line">                &#125;,</span><br><span class="line">                arguments: <span class="literal">None</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            Colon2,</span><br><span class="line">            PathSegment &#123;</span><br><span class="line">                ident: Ident &#123;</span><br><span class="line">                    ident: <span class="string">&quot;ideawand&quot;</span>,</span><br><span class="line">                    span: #<span class="number">0</span> bytes(<span class="number">1389</span>..<span class="number">1397</span>),</span><br><span class="line">                &#125;,</span><br><span class="line">                arguments: <span class="literal">None</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            Colon2,</span><br><span class="line">            PathSegment &#123;</span><br><span class="line">                ident: Ident &#123;</span><br><span class="line">                    ident: <span class="string">&quot;com&quot;</span>,</span><br><span class="line">                    span: #<span class="number">0</span> bytes(<span class="number">1399</span>..<span class="number">1402</span>),</span><br><span class="line">                &#125;,</span><br><span class="line">                arguments: <span class="literal">None</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    tokens: TokenStream [</span><br><span class="line">        Group &#123;</span><br><span class="line">            delimiter: Parenthesis,</span><br><span class="line">            stream: TokenStream [</span><br><span class="line">                Ident &#123;</span><br><span class="line">                    ident: <span class="string">&quot;Bar&quot;</span>,</span><br><span class="line">                    span: #<span class="number">0</span> bytes(<span class="number">1403</span>..<span class="number">1406</span>),</span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">            span: #<span class="number">0</span> bytes(<span class="number">1402</span>..<span class="number">1407</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>简单解释一下，就是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#[blog::ideawand::com(Bar)]</span><br><span class="line">^ ^^^^^^^^^^^^^^^^^^^ ^^^</span><br><span class="line">|         |            |</span><br><span class="line">|         |            +--这里对应的是&#96;syn::Attribute&#96;节点的&#96;tokens&#96;属性,它的类型是&#96;proc_macro2::TokenStream&#96;</span><br><span class="line">|         +--这里对应的是&#96;syn::Attribute&#96;节点的&#96;path&#96;属性,它的类型是&#96;syn::Path&#96;,这个语法树节点我们在前面已经见到过了</span><br><span class="line">+--这里对应&#96;syn::Attribute&#96;节点的&#96;style&#96;属性，&#96;#&#96;现在对应到的是&#96;outer&#96;,如果是&#96;#!&#96;对应处的就是&#96;inner&#96;</span><br></pre></td></tr></table></figure>

<p>上面的<code>style</code>和<code>path</code>两个字段都没什么要说的，好玩并且复杂的事情是<code>tokens</code>这个属性，我们可以看到，这个属性的类型并没有在<code>syn</code>包中定义对应的语法树节点，这是为什么呢？查看官方文档，我们可以了解到其背后的原因是：</p>
<ul>
<li>Rust 属性的书写语法非常灵活，甚至可以不是有效的Rust标准语法，例如包含用户自定义的语法规则，因此，<code>syn</code>包没法通过有限的语法树节点类型来表示它的内容</li>
<li>之所以要为<code>syn::Attribute</code>节点设置一个<code>path</code>部分，是可以把<code>path</code>作为一个类型提示，过程宏或者编译器可以根据<code>path</code>来决定如何解析后面的<code>token</code>部分</li>
<li>如果在你的自定义属性中，要求属性是符合标准Rust语法的，那么<code>syn::Attribute</code>节点提供了一个<code>parse_meta()</code>方法，可以将整个属性（也就是<code>path</code>和<code>token</code>两部分）中的内容解析为<code>syn::Meta</code>枚举类型，而这个枚举类型的内容又十分丰富。</li>
</ul>
<p><code>syn::Meta</code>枚举各个成员的含义：</p>
<ul>
<li><code>syn::Meta::Path</code>表示一个路径，下面这些形式的都可以认为是路径：<ul>
<li><code>#[A]</code>中的<code>A</code>,它只有一个小节，没有<code>::</code>分割的多个小节，但它也是一个Path</li>
<li><code>#[A::B::C]</code>中的<code>A::B::C</code></li>
</ul>
</li>
<li><code>syn::Meta::List</code>表示一个列表，这个列表必须由一个前置路径和一个括号标记组成，括号里面通过逗号分隔为多个条目，组成一个列表，列表中的每一个条目又是一个<code>syn::Meta</code>枚举<ul>
<li><code>#[Foo(AAA,BBB,CCC)]</code>中的<code>Foo</code>是前置路径，后面的<code>AAA</code>、<code>BBB</code>、<code>CCC</code>就是三个列表项，它们三个都是<code>syn::Meta</code>类型的枚举<ul>
<li>从形式上可以看出，这三个枚举类型实际上存放的又是三个<code>syn::Path</code>类型的数据</li>
</ul>
</li>
<li><code>#[Foo(AAA,BBB(CCC,DDD))]</code> 这种形式，演示了列表中每个项目是可以嵌套的，其中的<code>BBB</code>是嵌套内层<code>syn::Meta::List</code>的前置路径，而<code>CCC</code>和<code>DDD</code>是内层的列表项</li>
</ul>
</li>
<li><code>syn::Meta::NameValue</code>表示一个kv对，其中key部分是一个<code>syn::Path</code>,而value部分是一个字符串字面量<ul>
<li><code>#[xxx = &quot;yyy&quot;]</code>就是一个典型的例子</li>
</ul>
</li>
</ul>
<p>通过上面的嵌套规则可以看出，Rust允许你书写的属性规则是非常灵活的，例如你可以书写这样的一个属性，你可以尝试解释一下下面这个属性的嵌套层级：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#[Foo::Bar(A1::A2(B1::B2&#x3D;&quot;C&quot;,D&#x3D;&quot;E&quot;,F1::F2,G,H(I,J)))]</span><br></pre></td></tr></table></figure>


<p>大家可以通过修改<code>proc-macro-workshop/main.rs</code>中的代码来尝试各种不同形式的Attribute是如何被解析为<code>syn::Meta</code>类型的枚举的，当然，需要修改一下<code>proc-macro-workshop/builder/src/lib.rs</code>的测试派生宏的定义代码如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[proc_macro_derive(ExploreAttribute)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">attribute_explore</span></span>(input: TokenStream) -&gt; TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> st = syn::parse_macro_input!(input <span class="keyword">as</span> syn::DeriveInput);</span><br><span class="line">    <span class="keyword">let</span> attr = st.attrs.first().unwrap();</span><br><span class="line">    <span class="keyword">let</span> meta = attr.parse_meta(); <span class="comment">// 解析为`sny::Meta`对象</span></span><br><span class="line">    eprintln!(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, meta);</span><br><span class="line">    proc_macro2::TokenStream::new().into()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们回归正题，看一下第七关的题目，我们要解析形如<code>#[builder(each = &quot;arg&quot;)]</code>的惰性属性，分解一下，首先这是一个<code>syn::Meta::List</code>枚举成员，它的前置路径是<code>builder</code>，后面的列表里有一个<code>syn::Meta::NameValue</code>枚举成员，在这个kv对中，<code>each</code>是固定的，而后面的值，我们要把它当做一个ident来使用，拼接到生成的代码中。开始撸代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_user_specified_ident_for_vec</span></span>(field: &amp;syn::Field) -&gt; <span class="built_in">Option</span>&lt;syn::Ident&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> &amp;field.attrs &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Ok</span>(syn::Meta::List(syn::MetaList &#123;</span><br><span class="line">            <span class="keyword">ref</span> path,</span><br><span class="line">            <span class="keyword">ref</span> nested,</span><br><span class="line">            ..</span><br><span class="line">        &#125;)) = attr.parse_meta()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(p) = path.segments.first() &#123;</span><br><span class="line">                <span class="keyword">if</span> p.ident == <span class="string">&quot;builder&quot;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(syn::NestedMeta::Meta(syn::Meta::NameValue(kv))) = nested.first() &#123;</span><br><span class="line">                        <span class="keyword">if</span> kv.path.is_ident(<span class="string">&quot;each&quot;</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> <span class="keyword">let</span> syn::Lit::Str(<span class="keyword">ref</span> ident_str) = kv.lit &#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">Some</span>(syn::Ident::new(</span><br><span class="line">                                    ident_str.value().as_str(),</span><br><span class="line">                                    attr.span(),</span><br><span class="line">                                ));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">None</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析Attribute的工作完成了，但为了使用上面的函数我们还得费一番脑筋，做出不少修改，让我们来仔细看看第七关题目给出的要求：</p>
<ul>
<li><p>我们需要兼容指定了each属性的字段和没有指定each属性的字段：</p>
<ul>
<li>如果指定了each属性，又分为两种情况：<ul>
<li>如果each指定的名字和原始字段名一致，则只产生出每次追加一个值的setter函数</li>
<li>如果each指定的名字和原始字段名不一致，则需要产生两个版本的函数：<ul>
<li>与原始字段名同名的函数用于接收一个完整列表</li>
<li>用户指定名称的setter，每次只接收一个条目</li>
</ul>
</li>
<li>Vec字段和Option字段一样，不需要做为空的检查，对于Vec字段，我们要将其自动初始化</li>
</ul>
</li>
<li>如果没指定each属性，则可以把这个字段看做一个普通类型对待，前六关的测试用例还得通过才行</li>
</ul>
</li>
<li><p>为了实现上面的需求，我们之前每一个函数几乎都要修改。在前四关中，我给出了三种拼接<code>TokenStream</code>的方法，在这次大改造中你会发现：</p>
<ul>
<li>对于一些简单的拼接，使用迭代器和<code>quote!</code>宏的重复展开功能，几行简短的代码就可以优雅地实现拼接（第一关和第二关的写法），但对于复杂的需求，写起来就会很别扭</li>
<li>对于有比较复杂逻辑的生成业务，自己维护一个<code>Vec&lt;TokenStream&gt;</code>数组，或者自己去extend一个<code>TokenStream</code>会更加灵活顺手（也就是第三关和第四关的写法）</li>
</ul>
</li>
</ul>
<p>有了上面的大方向，我们开始继续撸代码。</p>
<p>第一个修改点是，因为我们这次不仅要获取<code>Option&lt;T&gt;</code>的内部类型，还有处理<code>Vec&lt;T&gt;</code>,所以我们来修改一下之前的<code>get_optional_inner_type()</code>函数，使其能够被复用，我们将其重命名为<code>get_generic_inner_type()</code>,新的定义如下，修改完成后，需要调整一下之前调用它的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_generic_inner_type</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(ty: &amp;<span class="symbol">&#x27;a</span> syn::Type, outer_ident_name: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Option</span>&lt;&amp;<span class="symbol">&#x27;a</span> syn::Type&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> syn::Type::Path(syn::TypePath &#123; <span class="keyword">ref</span> path, .. &#125;) = ty &#123;</span><br><span class="line">        <span class="comment">// 这里我们取segments的最后一节来判断是不是`T&lt;U&gt;`，这样如果用户写的是`foo:bar::T&lt;U&gt;`我们也能识别出最后的`T&lt;U&gt;`</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(seg) = path.segments.last() &#123;</span><br><span class="line">            <span class="keyword">if</span> seg.ident == outer_ident_name &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> syn::PathArguments::AngleBracketed(syn::AngleBracketedGenericArguments &#123;</span><br><span class="line">                    <span class="keyword">ref</span> args,</span><br><span class="line">                    ..</span><br><span class="line">                &#125;) = seg.arguments</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(syn::GenericArgument::Type(inner_ty)) = args.first() &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">Some</span>(inner_ty);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">None</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来一个个调整之前编写的函数，首先是<code>generate_builder_struct_fields_def()</code>函数，修改点在注释中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generate_builder_struct_fields_def</span></span>(</span><br><span class="line">    fields: &amp;StructFields,</span><br><span class="line">) -&gt; syn::<span class="built_in">Result</span>&lt;proc_macro2::TokenStream&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> idents: <span class="built_in">Vec</span>&lt;_&gt; = fields.iter().map(|f| &amp;f.ident).collect();</span><br><span class="line">    <span class="keyword">let</span> types: <span class="built_in">Vec</span>&lt;_&gt; = fields</span><br><span class="line">        .iter()</span><br><span class="line">        .map(|f| &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(inner_ty) = get_generic_inner_type(&amp;f.ty,<span class="string">&quot;Option&quot;</span>) &#123;</span><br><span class="line">                quote!(std::option::<span class="built_in">Option</span>&lt;#inner_ty&gt;)</span><br><span class="line">            <span class="comment">// 以下三行是第七关新加入的</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> get_user_specified_ident_for_vec(f).is_some() &#123;</span><br><span class="line">                <span class="keyword">let</span> origin_ty = &amp;f.ty;</span><br><span class="line">                quote!(#origin_ty)  <span class="comment">// 题目中设定，如果用户指定了each属性，我们就可以认为它一定是作用在一个Vec字段上</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> origin_ty = &amp;f.ty;</span><br><span class="line">                quote!(std::option::<span class="built_in">Option</span>&lt;#origin_ty&gt;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> token_stream = quote! &#123;</span><br><span class="line">        #(#idents: #types),*</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="literal">Ok</span>(token_stream)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是初始化函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generate_builder_struct_factory_init_clauses</span></span>(fields: &amp;StructFields) -&gt; syn::<span class="built_in">Result</span>&lt;<span class="built_in">Vec</span>&lt;proc_macro2::TokenStream&gt;&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> init_clauses: <span class="built_in">Vec</span>&lt;_&gt; = fields.iter().map(|f| &#123;</span><br><span class="line">        <span class="keyword">let</span> ident = &amp;f.ident;</span><br><span class="line">        <span class="comment">// 下面这个if分支是第七关加入的，在第六关的时候只有else分支里的代码</span></span><br><span class="line">        <span class="keyword">if</span> get_user_specified_ident_for_vec(f).is_some() &#123;</span><br><span class="line">            quote!&#123;</span><br><span class="line">                #ident: std::vec::<span class="built_in">Vec</span>::new()  <span class="comment">//指定了each属性的Vec需要初始化</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            quote!&#123;</span><br><span class="line">                #ident: std::option::<span class="built_in">Option</span>::<span class="literal">None</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).collect();</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(init_clauses)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是setter的生成：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generate_setter_functions</span></span>(fields: &amp;StructFields) -&gt; syn::<span class="built_in">Result</span>&lt;proc_macro2::TokenStream&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> idents: <span class="built_in">Vec</span>&lt;_&gt; = fields.iter().map(|f| &amp;f.ident).collect();</span><br><span class="line">    <span class="keyword">let</span> types: <span class="built_in">Vec</span>&lt;_&gt; = fields.iter().map(|f| &amp;f.ty).collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> final_tokenstream = proc_macro2::TokenStream::new();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第七关修改，这里之前用了zip串联了两个迭代器，现在需要拿到对应的原始field，所以又加了一层`enumerate()`迭代器</span></span><br><span class="line">    <span class="comment">// 这里写成 for idx in 0..fields.len() &#123;let ident = &amp;fields[idx].ident; let type_ = &amp;fields[idx].ty;...&#125; 这种写法或许更优雅一些</span></span><br><span class="line">    <span class="keyword">for</span> (idx,(ident, type_)) <span class="keyword">in</span> idents.iter().zip(types.iter()).enumerate() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> tokenstream_piece;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(inner_ty) = get_generic_inner_type(type_,<span class="string">&quot;Option&quot;</span>) &#123;</span><br><span class="line">            tokenstream_piece = quote! &#123;</span><br><span class="line">                <span class="function"><span class="keyword">fn</span> #<span class="title">ident</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, #ident: #inner_ty) -&gt; &amp;<span class="keyword">mut</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">                    <span class="keyword">self</span>.#ident = std::option::<span class="built_in">Option</span>::<span class="literal">Some</span>(#ident);</span><br><span class="line">                    <span class="keyword">self</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下面这个分支是第七关加入的</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="keyword">ref</span> user_specified_ident) = get_user_specified_ident_for_vec(&amp;fields[idx]) &#123;</span><br><span class="line">            <span class="keyword">let</span> inner_ty = get_generic_inner_type(type_,<span class="string">&quot;Vec&quot;</span>).ok_or(syn::Error::new(fields[idx].span(),<span class="string">&quot;each field must be specified with Vec field&quot;</span>))?;</span><br><span class="line">            tokenstream_piece = quote! &#123;</span><br><span class="line">                <span class="function"><span class="keyword">fn</span> #<span class="title">user_specified_ident</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, #user_specified_ident: #inner_ty) -&gt; &amp;<span class="keyword">mut</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">                    <span class="keyword">self</span>.#ident.push(#user_specified_ident);</span><br><span class="line">                    <span class="keyword">self</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 如果用户指定的setter名字和原始字段的名字不一样，那么产生另一个setter，这个setter是一次性传入一个列表的</span></span><br><span class="line">            <span class="keyword">if</span> user_specified_ident != ident.as_ref().unwrap() &#123;</span><br><span class="line">                tokenstream_piece.extend(</span><br><span class="line">                    quote! &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">fn</span> #<span class="title">ident</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, #ident: #type_) -&gt; &amp;<span class="keyword">mut</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">                            <span class="keyword">self</span>.#ident = #ident.clone();</span><br><span class="line">                            <span class="keyword">self</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tokenstream_piece = quote! &#123;</span><br><span class="line">                <span class="function"><span class="keyword">fn</span> #<span class="title">ident</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, #ident: #type_) -&gt; &amp;<span class="keyword">mut</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">                    <span class="keyword">self</span>.#ident = std::option::<span class="built_in">Option</span>::<span class="literal">Some</span>(#ident);</span><br><span class="line">                    <span class="keyword">self</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        final_tokenstream.extend(tokenstream_piece);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(final_tokenstream)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是我们的<code>build()</code>方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generate_build_function</span></span>(</span><br><span class="line">    fields: &amp;StructFields,</span><br><span class="line">    origin_struct_ident: &amp;syn::Ident,</span><br><span class="line">) -&gt; syn::<span class="built_in">Result</span>&lt;proc_macro2::TokenStream&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> idents: <span class="built_in">Vec</span>&lt;_&gt; = fields.iter().map(|f| &amp;f.ident).collect();</span><br><span class="line">    <span class="keyword">let</span> types: <span class="built_in">Vec</span>&lt;_&gt; = fields.iter().map(|f| &amp;f.ty).collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> checker_code_pieces = <span class="built_in">Vec</span>::new();</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..idents.len() &#123;</span><br><span class="line">        <span class="keyword">let</span> ident = idents[idx];</span><br><span class="line">        <span class="comment">// 第七关修改，只对不是`Option`类型且没有指定each属性的字段生成校验逻辑</span></span><br><span class="line">        <span class="keyword">if</span> get_generic_inner_type(&amp;types[idx],<span class="string">&quot;Option&quot;</span>).is_none() &amp;&amp; get_user_specified_ident_for_vec(&amp;fields[idx]).is_none() &#123;</span><br><span class="line">            checker_code_pieces.push(quote! &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">self</span>.#ident.is_none() &#123;</span><br><span class="line">                    <span class="keyword">let</span> err = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125; field missing&quot;</span>, <span class="built_in">stringify!</span>(#ident));</span><br><span class="line">                    <span class="keyword">return</span> std::result::<span class="built_in">Result</span>::<span class="literal">Err</span>(err.into())</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> fill_result_clauses = <span class="built_in">Vec</span>::new();</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..idents.len() &#123;</span><br><span class="line">        <span class="keyword">let</span> ident = idents[idx];</span><br><span class="line">        <span class="comment">// 第七关，这里需要判断是否有each属性。第一个分支是本关加入的。注意这里几个分支的先后判断顺序</span></span><br><span class="line">        <span class="comment">// 看我写在这里的代码可能没什么感觉，但如果是自己写的话，这几个分支的判断先后顺序是很重要的，否则可能生成出有问题的代码</span></span><br><span class="line">        <span class="comment">// 这里主要的问题是梳理清楚【是否有each属性】和【是否为Option类型】这两个条件的覆盖范围</span></span><br><span class="line">        <span class="keyword">if</span> get_user_specified_ident_for_vec(&amp;fields[idx]).is_some() &#123;</span><br><span class="line">            fill_result_clauses.push(quote! &#123;</span><br><span class="line">                #ident: <span class="keyword">self</span>.#ident.clone()</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> get_generic_inner_type(&amp;types[idx],<span class="string">&quot;Option&quot;</span>).is_none() &#123;</span><br><span class="line">            fill_result_clauses.push(quote! &#123;</span><br><span class="line">                #ident: <span class="keyword">self</span>.#ident.clone().unwrap()</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fill_result_clauses.push(quote! &#123;</span><br><span class="line">                #ident: <span class="keyword">self</span>.#ident.clone()</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> token_stream = quote! &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">build</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; std::result::<span class="built_in">Result</span>&lt;#origin_struct_ident, std::boxed::<span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt; &#123;</span><br><span class="line">            #(#checker_code_pieces)*</span><br><span class="line">            <span class="keyword">let</span> ret = #origin_struct_ident&#123;</span><br><span class="line">                #(#fill_result_clauses),*</span><br><span class="line">            &#125;;</span><br><span class="line">            std::result::<span class="built_in">Result</span>::<span class="literal">Ok</span>(ret)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="literal">Ok</span>(token_stream)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大功告成</p>
<h3 id="第八关"><a href="#第八关" class="headerlink" title="第八关"></a>第八关</h3><p>第八、九关视频版本：</p>
<iframe src="//player.bilibili.com/player.html?aid=247776475&bvid=BV1vv411L7XQ&cid=331683140&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>这一关是一个如何打印友好错误信息的挑战，完成这个挑战时，因为会拿编译器输出的结果做字符串匹配比较，所以我们要保证代码的干净，清除掉所有的未引入引用等Warning</p>
<p>首先把错误产生出来，我们需要修改<code>get_user_specified_ident_for_vec()</code>函数，让他返回一个<code>syn::Result</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_user_specified_ident_for_vec</span></span>(field: &amp;syn::Field) -&gt; syn::<span class="built_in">Result</span>&lt;<span class="built_in">Option</span>&lt;syn::Ident&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> &amp;field.attrs &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Ok</span>(syn::Meta::List(syn::MetaList &#123;</span><br><span class="line">            <span class="keyword">ref</span> path,</span><br><span class="line">            <span class="keyword">ref</span> nested,</span><br><span class="line">            ..</span><br><span class="line">        &#125;)) = attr.parse_meta()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(p) = path.segments.first() &#123;</span><br><span class="line">                <span class="keyword">if</span> p.ident == <span class="string">&quot;builder&quot;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(syn::NestedMeta::Meta(syn::Meta::NameValue(kv))) = nested.first() &#123;</span><br><span class="line">                        <span class="keyword">if</span> kv.path.is_ident(<span class="string">&quot;each&quot;</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> <span class="keyword">let</span> syn::Lit::Str(<span class="keyword">ref</span> ident_str) = kv.lit &#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">Ok</span>(<span class="literal">Some</span>(syn::Ident::new(</span><br><span class="line">                                    ident_str.value().as_str(),</span><br><span class="line">                                    attr.span(),</span><br><span class="line">                                )));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 第八关加入，注意这里new_spanned函数的参数，我们需要在语法树中找到一个合适的节点来获取它的span，如果这个语法树节点找的不对，产生出的错误信息就会不一样</span></span><br><span class="line">                            <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Ok</span>(syn::Meta::List(<span class="keyword">ref</span> list)) = attr.parse_meta() &#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">Err</span>(syn::Error::new_spanned(list, <span class="string">r#&quot;expected `builder(each = &quot;...&quot;)`&quot;#</span>))</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">Ok</span>(<span class="literal">None</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上面的代码，我们需要找到一个合适的语法树节点来产生错误的位置，例如，上面代码我们使用了语法树中的<code>syn::MetaList</code>节点，产生的报错信息是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error: expected &#96;builder(each &#x3D; &quot;...&quot;)&#96;</span><br><span class="line">  --&gt; $DIR&#x2F;08-unrecognized-attribute.rs:22:7</span><br><span class="line">   |</span><br><span class="line">22 |     #[builder(eac &#x3D; &quot;arg&quot;)]</span><br><span class="line">   |       ^^^^^^^^^^^^^^^^^^^^</span><br></pre></td></tr></table></figure>
<p>而如果将上面<code>new_spanned</code>函数的第一个传入参数从<code>list</code>改为<code>attr</code>，即我们使用了<code>syn::Attribute</code>这个语法树节点的时候，给出的错误信息就会是这样的，注意其中<code>^</code>符号数量和位置的变化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error: expected &#96;builder(each &#x3D; &quot;...&quot;)&#96;</span><br><span class="line">  --&gt; $DIR&#x2F;08-unrecognized-attribute.rs:22:5</span><br><span class="line">   |</span><br><span class="line">22 |     #[builder(eac &#x3D; &quot;arg&quot;)]</span><br><span class="line">   |     ^^^^^^^^^^^^^^^^^^^^^^^</span><br></pre></td></tr></table></figure>

<p>可以返回Result以后，对这个函数的调用部分也需要改一下，对于普通的调用，我们直接在后面加一个<code>?</code>就好了，但是有两个函数是在迭代器map的闭包里调用了，这样改起来就有些麻烦了，这也再一次印证了上面的观点：对于复杂的过程宏，少用迭代器的map方法，自己构建循环展开可控性更好！</p>
<p>首先是<code>generate_builder_struct_fields_def()</code>函数，可以参考注释：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generate_builder_struct_fields_def</span></span>(</span><br><span class="line">    fields: &amp;StructFields,</span><br><span class="line">) -&gt; syn::<span class="built_in">Result</span>&lt;proc_macro2::TokenStream&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> idents: <span class="built_in">Vec</span>&lt;_&gt; = fields.iter().map(|f| &amp;f.ident).collect();</span><br><span class="line">    <span class="comment">// 第八关修改，从这里又可以看出，对于复杂的过程宏，采用迭代器比较麻烦，返回一个错误要费一些周折</span></span><br><span class="line">    <span class="comment">// 这里修改了map中闭包的返回值，使其返回一个syn::Result&lt;T&gt;</span></span><br><span class="line">    <span class="keyword">let</span> types: syn::<span class="built_in">Result</span>&lt;<span class="built_in">Vec</span>&lt;proc_macro2::TokenStream&gt;&gt; = fields</span><br><span class="line">        .iter()</span><br><span class="line">        .map(|f| &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(inner_ty) = get_generic_inner_type(&amp;f.ty,<span class="string">&quot;Option&quot;</span>) &#123;</span><br><span class="line">                <span class="literal">Ok</span>(quote!(std::option::<span class="built_in">Option</span>&lt;#inner_ty&gt;))</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> get_user_specified_ident_for_vec(f)?.is_some() &#123;</span><br><span class="line">                <span class="keyword">let</span> origin_ty = &amp;f.ty;</span><br><span class="line">                <span class="literal">Ok</span>(quote!(#origin_ty)) </span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> origin_ty = &amp;f.ty;</span><br><span class="line">               <span class="literal">Ok</span>(quote!(std::option::<span class="built_in">Option</span>&lt;#origin_ty&gt;))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .collect();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> types = types?;</span><br><span class="line">    <span class="keyword">let</span> token_stream = quote! &#123;</span><br><span class="line">        #(#idents: #types),*</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="literal">Ok</span>(token_stream)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是<code>generate_builder_struct_factory_init_clauses()</code>函数:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generate_builder_struct_factory_init_clauses</span></span>(fields: &amp;StructFields) -&gt; syn::<span class="built_in">Result</span>&lt;<span class="built_in">Vec</span>&lt;proc_macro2::TokenStream&gt;&gt;&#123;</span><br><span class="line">    <span class="comment">// 第八关修改，从闭包中返回错误信息</span></span><br><span class="line">    <span class="keyword">let</span> init_clauses: syn::<span class="built_in">Result</span>&lt;<span class="built_in">Vec</span>&lt;proc_macro2::TokenStream&gt;&gt; = fields.iter().map(|f| &#123;</span><br><span class="line">        <span class="keyword">let</span> ident = &amp;f.ident;</span><br><span class="line">        <span class="keyword">if</span> get_user_specified_ident_for_vec(f)?.is_some() &#123;</span><br><span class="line">            <span class="literal">Ok</span>(quote!&#123;</span><br><span class="line">                #ident: std::vec::<span class="built_in">Vec</span>::new()  </span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">Ok</span>(quote!&#123;</span><br><span class="line">                #ident: std::option::<span class="built_in">Option</span>::<span class="literal">None</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).collect();</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(init_clauses?)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终于，大功告成！</p>
<h3 id="第九关"><a href="#第九关" class="headerlink" title="第九关"></a>第九关</h3><p>哈哈哈，由于我们之前已经严格遵守了规定，第九关自然就通过了。不过，关于第九关的知识点，我还是要给大家再明确一下：</p>
<ul>
<li>我们说的要使用绝对路径，是在生成的代码中要使用绝对路径</li>
<li>过程宏本身的代码，也就是我们用来生成代码的代码，里面还是可以直接使用短名字的</li>
<li>过程宏代码，和过程宏生成的代码，编译和运行在两个完全独立的时间以及空间上，请大家一定要想清楚~</li>
</ul>

    </div>

    
    
    <img src="/images/qrcode_for_gh_d3fcb061f2e4_258.jpg" width="25%" height="25%"/>
<div align="center">
<div>微信公众号：极客幼稚园</div>
<div>关注阅读更多优质技术文章</div>
</div>


        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Myrfy
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://blog.ideawand.com/2021/03/24/rust_procedural_macro/rust_proc_marco_workshop_guide-02/" title="Rust过程宏系列教程(2)--实现proc-macro-workshop项目之Builder题目">http://blog.ideawand.com/2021/03/24/rust_procedural_macro/rust_proc_marco_workshop_guide-02/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/null" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-ND</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Rust-%E8%BF%87%E7%A8%8B%E5%AE%8F-proc-macro-proc-macro-workshop/" rel="tag"># Rust,过程宏,proc-macro,proc-macro-workshop</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2021/02/27/rust_procedural_macro/rust_proc_marco_workshop_guide-01/" rel="next" title="Rust过程宏系列教程(1)--搭建过程宏开发环境并熟悉基本原理">
                  <i class="fa fa-chevron-left"></i> Rust过程宏系列教程(1)--搭建过程宏开发环境并熟悉基本原理
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2021/06/26/rust_procedural_macro/rust_proc_marco_workshop_guide-03/" rel="prev" title="Rust过程宏系列教程(3)--实现proc_macro_workshop项目之debug题目">
                  Rust过程宏系列教程(3)--实现proc_macro_workshop项目之debug题目 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E5%85%B3"><span class="nav-number">1.</span> <span class="nav-text">第一关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E5%85%B3"><span class="nav-number">2.</span> <span class="nav-text">第二关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E5%85%B3"><span class="nav-number">3.</span> <span class="nav-text">第三关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E5%85%B3"><span class="nav-number">4.</span> <span class="nav-text">第四关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E5%85%B3"><span class="nav-number">5.</span> <span class="nav-text">第五关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E5%85%B3"><span class="nav-number">6.</span> <span class="nav-text">第六关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E5%85%B3"><span class="nav-number">7.</span> <span class="nav-text">第七关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E5%85%B3"><span class="nav-number">8.</span> <span class="nav-text">第八关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E5%85%B3"><span class="nav-number">9.</span> <span class="nav-text">第九关</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Myrfy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/null" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-nd.svg" alt="Creative Commons"></a>
  </div>


<img src="/images/qrcode_for_gh_d3fcb061f2e4_258.jpg" width="70%" height="70%"/>
<div>微信公众号：极客幼稚园</div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Myrfy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v6.3.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
















  

  

</body>
</html>
